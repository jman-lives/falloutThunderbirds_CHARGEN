<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Play Game - Fallout Character Generator</title>
  <link rel="stylesheet" href="styles.css" />
  <script src="script.js" defer></script>
  <script src="advancement.js" defer></script>
  <style>
    .game-container {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .character-sheet {
      background: rgba(255, 255, 255, 0.02);
      padding: 16px;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .character-header {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr 1fr 1fr;
      gap: 12px;
      margin-bottom: 16px;
    }

    .stat-block {
      padding: 8px;
      background: rgba(255, 255, 255, 0.03);
      border-radius: 4px;
      border-left: 3px solid #60a5fa;
    }

    .stat-label {
      font-size: 0.75rem;
      color: var(--muted);
      margin-bottom: 4px;
    }

    .stat-value {
      font-size: 1.2rem;
      font-weight: bold;
      color: #4CAF50;
    }

    .attributes-grid {
      display: grid;
      grid-template-columns: repeat(7, 1fr);
      gap: 8px;
      margin-bottom: 16px;
    }

    .attribute {
      padding: 8px;
      background: rgba(255, 255, 255, 0.03);
      border-radius: 4px;
      text-align: center;
      border-left: 2px solid #FF9800;
    }

    .attribute-name {
      font-size: 0.7rem;
      color: var(--muted);
      margin-bottom: 4px;
    }

    .attribute-value {
      font-weight: bold;
      color: #fbbf24;
      font-size: 1rem;
    }

    .button-group {
      display: flex;
      gap: 8px;
      margin-top: 16px;
    }

    .btn {
      flex: 1;
      padding: 12px;
      background-color: #60a5fa;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-weight: bold;
      transition: all 0.2s ease;
    }

    .btn:hover {
      background-color: #3b82f6;
      transform: translateY(-2px);
    }

    .btn-secondary {
      background-color: #10b981;
    }

    .btn-secondary:hover {
      background-color: #059669;
    }

    .btn-danger {
      background-color: #ef4444;
    }

    .btn-danger:hover {
      background-color: #dc2626;
    }

    .placeholder {
      text-align: center;
      color: var(--muted);
      padding: 32px;
      font-style: italic;
    }

    @media (max-width: 640px) {
      .character-header {
        grid-template-columns: 1fr 1fr;
      }

      .attributes-grid {
        grid-template-columns: repeat(4, 1fr);
      }

      .button-group {
        flex-direction: column;
      }
    }
  </style>
</head>
<body>
  <main class="container">
    <h1>Play Game</h1>

    <div class="controls" style="margin-bottom: 16px; display: flex; gap: 8px; align-items: stretch;">
      <div id="active-item-display" style="flex: 1; padding: 12px; background-color: #10b981; color: white; border-radius: 4px; font-weight: bold; display: flex; align-items: center; justify-content: space-between;">
        <div>
          <div style="font-size: 0.75rem; color: rgba(255,255,255,0.7); margin-bottom: 4px;">Active Item</div>
          <div id="active-item-name" style="font-size: 1.1rem;">‚Äî</div>
        </div>
        <div style="display: flex; gap: 8px;">
          <button id="targeted-attack-btn" onclick="targetedAttack()" style="display: none; padding: 8px 20px; background-color: #eab308; color: white; border: 2px solid #eab308; border-radius: 4px; cursor: pointer; font-weight: bold; font-size: 1.5rem; transition: all 0.2s ease;" onmouseover="this.style.backgroundColor='#ca8a04'; this.style.borderColor='#ca8a04'; this.style.transform='translateY(-2px)'" onmouseout="this.style.backgroundColor='#eab308'; this.style.borderColor='#eab308'; this.style.transform='translateY(0)'">üéØ</button>
          <button id="use-item-btn" onclick="useActiveItem()" style="padding: 8px 20px; background-color: #dc2626; color: white; border: 2px solid #dc2626; border-radius: 4px; cursor: pointer; font-weight: bold; transition: all 0.2s ease;" onmouseover="this.style.backgroundColor='#b91c1c'; this.style.borderColor='#b91c1c'; this.style.transform='translateY(-2px)'" onmouseout="this.style.backgroundColor='#dc2626'; this.style.borderColor='#dc2626'; this.style.transform='translateY(0)'">Use</button>
          <button id="burst-mode-toggle-btn" onclick="toggleBurstMode()" style="display: none; padding: 8px 16px; background-color: #64748b; color: white; border: 2px solid #64748b; border-radius: 4px; cursor: pointer; font-weight: bold; transition: all 0.2s ease; font-size: 1.2rem;" onmouseover="this.style.transform='translateY(-2px)'" onmouseout="this.style.transform='translateY(0)'">üîÑ</button>
          <button id="reload-item-btn" onclick="reloadActiveItem()" style="display: none; padding: 8px 20px; background-color: #2563eb; color: white; border: 2px solid #2563eb; border-radius: 4px; cursor: pointer; font-weight: bold; transition: all 0.2s ease;" onmouseover="this.style.backgroundColor='#1d4ed8'; this.style.borderColor='#1d4ed8'; this.style.transform='translateY(-2px)'" onmouseout="this.style.backgroundColor='#2563eb'; this.style.borderColor='#2563eb'; this.style.transform='translateY(0)'">Reload</button>
        </div>
      </div>
      <div style="display: flex; flex-direction: column; gap: 8px;">
        <button id="swap-btn" onclick="swapActiveItem()" style="padding: 12px 20px; background-color: #9C27B0; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: bold; transition: all 0.2s ease;" onmouseover="this.style.backgroundColor='#7B1FA2'; this.style.transform='translateY(-2px)'" onmouseout="this.style.backgroundColor='#9C27B0'; this.style.transform='translateY(0)'">Swap</button>
        <button id="config-btn" onclick="openEquipmentModal()" style="padding: 8px 16px; background-color: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: bold; font-size: 0.85rem; transition: all 0.2s ease;" onmouseover="this.style.backgroundColor='#388E3C'; this.style.transform='translateY(-2px)'" onmouseout="this.style.backgroundColor='#4CAF50'; this.style.transform='translateY(0)'">‚öô Set Items</button>
      </div>
    </div>

    <!-- Dice Table for Active Item -->
    <div id="dice-table-container" style="margin-bottom: 16px; background: rgba(255, 255, 255, 0.02); padding: 16px; border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.1);">
      <h3 style="margin-top: 0; margin-bottom: 12px; color: #FFD700;">Item Stats</h3>
      <div id="item-flavor-text" style="margin-bottom: 12px; padding: 8px; background: rgba(255, 152, 0, 0.1); border-left: 3px solid #FF9800; border-radius: 2px; color: #FFD700; font-size: 0.85rem; font-style: italic; min-height: 24px;">No item selected</div>
      <table id="dice-table" style="width: 100%; border-collapse: collapse; color: #aaa; font-size: 0.9rem;">
        <thead>
          <tr style="border-bottom: 2px solid #FF9800;">
            <th style="text-align: left; padding: 8px; color: #FF9800; font-weight: bold;">Stat</th>
            <th style="text-align: left; padding: 8px; color: #FF9800; font-weight: bold;">Value</th>
          </tr>
        </thead>
        <tbody id="dice-table-body">
          <tr>
            <td colspan="2" style="padding: 8px; text-align: center; color: #666;">No item selected</td>
          </tr>
        </tbody>
      </table>
    </div>

    <!-- Equipment Configuration Modal -->
    <div id="equipment-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000; align-items: center; justify-content: center;">
      <div style="background: #1a1a1a; border: 2px solid #FF9800; border-radius: 8px; padding: 24px; max-width: 800px; width: 90%; max-height: 80vh; overflow-y: auto;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
          <h2 style="margin: 0; color: #FF9800;">Configure Equipment</h2>
          <button onclick="closeEquipmentModal()" style="background: none; border: none; color: #FF9800; font-size: 1.5rem; cursor: pointer; padding: 0; width: 30px; height: 30px;">‚úï</button>
        </div>

        <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 20px; margin-bottom: 20px;">
          <!-- Available Items -->
          <div>
            <label style="display: block; color: #FFD700; font-weight: bold; margin-bottom: 12px;">Available Equipment</label>
            <div id="available-items" style="display: grid; grid-template-columns: 1fr; gap: 8px; min-height: 300px;"></div>
          </div>

          <!-- Drop Zones -->
          <div>
            <div style="margin-bottom: 16px;">
              <label style="display: block; color: #FFD700; font-weight: bold; margin-bottom: 8px;">Item 1</label>
              <div 
                id="drop-zone-1" 
                ondragover="handleDragOver(event)" 
                ondrop="handleDrop(event, 0)" 
                ondragleave="handleDragLeave(event)"
                style="min-height: 60px; padding: 12px; background-color: #2a2a2a; border: 2px dashed #FF9800; border-radius: 4px; display: flex; align-items: center; justify-content: space-between; cursor: drop; transition: all 0.2s ease;">
                <div id="item1-display" style="flex: 1; text-align: center; color: #999;">Drag item here</div>
                <button id="item1-remove" onclick="removeEquipmentSlot(0)" style="display: none; margin-left: 8px; background-color: #FF6B6B; color: white; border: none; border-radius: 3px; padding: 4px 8px; cursor: pointer; font-weight: bold; font-size: 0.9rem;">‚úï</button>
              </div>
            </div>

            <div>
              <label style="display: block; color: #FFD700; font-weight: bold; margin-bottom: 8px;">Item 2</label>
              <div 
                id="drop-zone-2" 
                ondragover="handleDragOver(event)" 
                ondrop="handleDrop(event, 1)" 
                ondragleave="handleDragLeave(event)"
                style="min-height: 60px; padding: 12px; background-color: #2a2a2a; border: 2px dashed #FF9800; border-radius: 4px; display: flex; align-items: center; justify-content: space-between; cursor: drop; transition: all 0.2s ease;">
                <div id="item2-display" style="flex: 1; text-align: center; color: #999;">Drag item here</div>
                <button id="item2-remove" onclick="removeEquipmentSlot(1)" style="display: none; margin-left: 8px; background-color: #FF6B6B; color: white; border: none; border-radius: 3px; padding: 4px 8px; cursor: pointer; font-weight: bold; font-size: 0.9rem;">‚úï</button>
              </div>
            </div>
          </div>

          <!-- Armor Slot -->
          <div>
            <div>
              <label style="display: block; color: #9C27B0; font-weight: bold; margin-bottom: 8px;">Armor</label>
              <div 
                id="drop-zone-armor" 
                ondragover="handleDragOver(event)" 
                ondrop="handleDrop(event, 2)" 
                ondragleave="handleDragLeave(event)"
                style="min-height: 60px; padding: 12px; background-color: #2a2a2a; border: 2px dashed #9C27B0; border-radius: 4px; display: flex; align-items: center; justify-content: space-between; cursor: drop; transition: all 0.2s ease;">
                <div id="armor-display" style="flex: 1; text-align: center; color: #999;">Drag armor here</div>
                <button id="armor-remove" onclick="removeEquipmentSlot(2)" style="display: none; margin-left: 8px; background-color: #FF6B6B; color: white; border: none; border-radius: 3px; padding: 4px 8px; cursor: pointer; font-weight: bold; font-size: 0.9rem;">‚úï</button>
              </div>
            </div>
          </div>
        </div>

        <div style="display: flex; gap: 8px; justify-content: flex-end;">
          <button onclick="closeEquipmentModal()" style="padding: 8px 16px; background-color: #666; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: bold;">Cancel</button>
          <button onclick="saveEquipmentConfiguration()" style="padding: 8px 16px; background-color: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: bold;">Save</button>
        </div>
      </div>
    </div>

    <div class="game-container">
      <div id="character-info" class="character-sheet">
        <h2 style="margin-top: 0;" id="char-name"></h2>
        
        <div class="character-header">
          <!-- <div class="stat-block">
            <div class="stat-label">Player</div>
            <div class="stat-value" id="play-name">‚Äî</div>
          </div> -->
          <div class="stat-block">
            <div class="stat-label">Race</div>
            <div class="stat-value" id="char-race">‚Äî</div>
          </div>
          <div class="stat-block">
            <div class="stat-label">Level</div>
            <div class="stat-value" id="char-level">‚Äî</div>
          </div>
          <div class="stat-block">
            <div class="stat-label">Action Points</div>
            <div class="stat-value" id="char-max-hp">‚Äî</div>
          </div>
          <div class="stat-block">
            <div class="stat-label">Sequence</div>
            <div class="stat-value" id="char-sequence">‚Äî</div>
          </div>
          <div class="stat-block">
            <div class="stat-label">Current Health</div>
            <div id="char-current-hp">‚Äî</div>
          </div>
        </div>

        <div class="character-header" style="margin-top: 12px;">
          <div class="stat-block">
            <div class="stat-label">Equipped Armor</div>
            <div class="stat-value" id="char-equipped-armor" style="color: #a78bfa;">‚Äî</div>
          </div>
          <div class="stat-block">
            <div class="stat-label">Armor Class</div>
            <div class="stat-value" id="char-armor-class" style="color: #9C27B0;">‚Äî</div>
          </div>
          <div class="stat-block">
            <div class="stat-label">Melee Damage</div>
            <div class="stat-value" id="char-melee-damage" style="color: #ef4444;">‚Äî</div>
          </div>
        </div>

        <h3 style="margin-bottom: 8px;">Attributes</h3>
        <div class="attributes-grid">
          <div class="attribute">
            <div class="attribute-name">STR</div>
            <div class="attribute-value" id="attr-str">‚Äî</div>
          </div>
          <div class="attribute">
            <div class="attribute-name">PER</div>
            <div class="attribute-value" id="attr-per">‚Äî</div>
          </div>
          <div class="attribute">
            <div class="attribute-name">END</div>
            <div class="attribute-value" id="attr-end">‚Äî</div>
          </div>
          <div class="attribute">
            <div class="attribute-name">CHR</div>
            <div class="attribute-value" id="attr-chr">‚Äî</div>
          </div>
          <div class="attribute">
            <div class="attribute-name">INT</div>
            <div class="attribute-value" id="attr-int">‚Äî</div>
          </div>
          <div class="attribute">
            <div class="attribute-name">AGI</div>
            <div class="attribute-value" id="attr-agi">‚Äî</div>
          </div>
          <div class="attribute">
            <div class="attribute-name">LCK</div>
            <div class="attribute-value" id="attr-lck">‚Äî</div>
          </div>
        </div>

        <!-- <h3 style="margin-bottom: 8px;">Skills</h3> -->
        <button id="skills-toggle" onclick="toggleSkillsAccordion()" style="width: 100%; padding: 10px; background-color: #9333ea; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: bold; text-align: left; transition: all 0.2s;">
          ‚ñº Show Skills
        </button>
        <div id="skills-container" style="display: none; margin-top: 8px;">
          <div id="skills-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 8px;"></div>
        </div>
      </div>

      <div id="traits-section" class="character-sheet">
        <button id="traits-toggle" onclick="toggleTraitsAccordion()" style="width: 100%; padding: 10px; background-color: #f97316; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: bold; text-align: left; transition: all 0.2s;">
          ‚ñº Show Traits
        </button>
        <div id="traits-container" style="display: none; margin-top: 8px; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 8px;"></div>
      </div>

      <div id="perks-section" class="character-sheet">
        <button id="perks-toggle" onclick="togglePerksAccordion()" style="width: 100%; padding: 10px; background-color: #3b82f6; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: bold; text-align: left; transition: all 0.2s;">
          ‚ñº Show Selected Perks
        </button>
        <p style="color: var(--muted); margin: 8px 0 12px 0; font-size: 0.9rem; display: none;" id="perks-desc">Your selected perks and their effects.</p>
        <div id="perks-container" style="display: none; margin-top: 8px; grid-template-columns: repeat(auto-fill, minmax(240px, 1fr)); gap: 8px;"></div>
      </div>

      <div id="effects-section" class="character-sheet">
        <button id="effects-toggle" onclick="toggleEffectsAccordion()" style="width: 100%; padding: 10px; background-color: #ec4899; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: bold; text-align: left; transition: all 0.2s;">
          ‚ñº Show Status Effects
        </button>
        <p style="color: var(--muted); margin: 8px 0 12px 0; font-size: 0.9rem; display: none;" id="effects-desc">Active status effects affecting your character.</p>
        <div id="effects-container" style="display: none; margin-top: 8px; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 8px;"></div>
      </div>

    <!-- <div id="tools-section" class="character-sheet" style="grid-column: 1/-1;">
        <button id="tools-toggle" onclick="toggleToolsAccordion()" style="width: 100%; padding: 12px; background-color: #8b5cf6; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: bold; text-align: left; transition: all 0.2s; font-size: 1.1rem;">
          ‚ñº Show Selected Tools
        </button>
        <p style="color: var(--muted); margin: 12px 0 16px 0; font-size: 0.95rem; display: none;" id="tools-desc">Your selected tools and their effects.</p>
        <div id="tools-container" style="display: none; margin-top: 12px; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 12px;"></div>
      </div> -->
    </div>

      <div class="button-group">
        <button class="btn btn-secondary" onclick="downloadCharacter()">üíæ Download Character</button>
      </div>
    </div>

    <footer style="text-align: center; padding: 20px; margin-top: 16px; border-top: 1px solid rgba(255, 255, 255, 0.1);">
      <a href="index.html" style="display: inline-block; padding: 6px 12px; background-color: #2196F3; color: white; border: none; border-radius: 4px; text-decoration: none; cursor: pointer; font-weight: bold; transition: all 0.2s ease;" onmouseover="this.style.backgroundColor='#1976D2'; this.style.transform='translateY(-2px)'" onmouseout="this.style.backgroundColor='#2196F3'; this.style.transform='translateY(0)'">‚Üê Back to Home</a>
    </footer>
  </main>

  <script>
    function qs(id) {
      return document.getElementById(id);
    }

    let maxHP = 15;

    const SKILL_NAMES = {
      'guns': 'Guns',
      'energy_weapons': 'Energy Weapons',
      'unarmed': 'Unarmed',
      'melee_weapons': 'Melee Weapons',
      'throwing': 'Throwing',
      'first_aid': 'First Aid',
      'doctor': 'Doctor',
      'sneak': 'Sneak',
      'lockpick': 'Lockpick',
      'steal': 'Steal',
      'traps': 'Traps',
      'science': 'Science',
      'repair': 'Repair',
      'pilot': 'Pilot',
      'speech': 'Speech',
      'barter': 'Barter',
      'gambling': 'Gambling',
      'outdoorsman': 'Outdoorsman'
    };

    function getHealthBarColor(percentage) {
      if (percentage > 50) {
        return 'linear-gradient(90deg, #4CAF50, #8BC34A)';
      } else if (percentage > 25) {
        return 'linear-gradient(90deg, #FF9800, #FFC107)';
      } else {
        return 'linear-gradient(90deg, #ef4444, #f87171)';
      }
    }

    function getHealthColor(percentage) {
      if (percentage > 50) {
        return '#4CAF50';
      } else if (percentage > 25) {
        return '#FFC107';
      } else {
        return '#ef4444';
      }
    }

    function renderHealthTracker(currentHP, maxHealth) {
      const container = qs('char-current-hp');
      // Ensure HP is never below 0 or above max
      currentHP = Math.max(0, Math.min(currentHP, maxHealth));
      const percentage = (currentHP / maxHealth) * 100;
      const healthColor = getHealthColor(percentage);
      const healthBarColor = getHealthBarColor(percentage);
      
      container.innerHTML = `
        <div style="font-size: 1.2rem; font-weight: bold; color: ${healthColor}; display: flex; flex-direction: column; gap: 8px;">
          <div>${currentHP}/${maxHealth} <span style="font-size: 0.9rem; color: #FF9800;">(${Math.round(percentage)}%)</span></div>
          <div style="height: 8px; background: rgba(0,0,0,0.3); border-radius: 2px; overflow: hidden;">
            <div style="height: 100%; background: ${healthBarColor}; width: ${percentage}%; transition: width 0.3s ease;"></div>
          </div>
          <div style="display: flex; gap: 4px;">
            <button 
              type="button"
              onclick="decreaseHP()"
              style="flex: 1; padding: 4px; background-color: #d32f2f; color: white; border: none; border-radius: 2px; cursor: pointer; font-size: 1rem; font-weight: bold; transition: all 0.2s;"
              title="Decrease HP"
              onmouseover="this.style.opacity='0.8'"
              onmouseout="this.style.opacity='1'"
            >
              ‚ñº
            </button>
            <button 
              type="button"
              onclick="increaseHP()"
              style="flex: 1; padding: 4px; background-color: #4CAF50; color: white; border: none; border-radius: 2px; cursor: pointer; font-size: 1rem; font-weight: bold; transition: all 0.2s;"
              title="Increase HP"
              onmouseover="this.style.opacity='0.8'"
              onmouseout="this.style.opacity='1'"
            >
              ‚ñ≤
            </button>
          </div>
        </div>
      `;
    }

    function renderSkills(skills, characterData) {
      const container = qs('skills-grid');
      
      if (!skills || Object.keys(skills).length === 0) {
        container.innerHTML = '<p style="color: #999;">No skills available.</p>';
        return;
      }

      const skillsHTML = Object.entries(skills).map(([skillId, value]) => {
        const skillName = SKILL_NAMES[skillId] || skillId.replace(/_/g, ' ').split(' ').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
        let skillValue = parseInt(value) || 0;
        
        // Apply conditional skill bonuses if perk/trait is active - STACKING
        let bonusValue = 0;
        const bonusBreakdown = [];
        
        if (skillId === 'speech') {
          if (localStorage.getItem('perk_active_smooth_talker') === 'true') {
            bonusValue += 5;
            bonusBreakdown.push('Smooth Talker +5%');
          }
          const selectedTraits = characterData.selectedTraits || [];
          if (selectedTraits.includes('sex_appeal') && localStorage.getItem('trait_active_sex_appeal') === 'true') {
            bonusValue += 40;
            bonusBreakdown.push('Sex Appeal +40%');
          }
        }
        if (skillId === 'barter') {
          const selectedTraits = characterData.selectedTraits || [];
          if (selectedTraits.includes('sex_appeal') && localStorage.getItem('trait_active_sex_appeal') === 'true') {
            bonusValue += 40;
            bonusBreakdown.push('Sex Appeal +40%');
          }
        }
        if (skillId === 'outdoorsman') {
          if (localStorage.getItem('perk_active_survivalist') === 'true') {
            bonusValue += 25;
            bonusBreakdown.push('Survivalist +25%');
          }
          if (localStorage.getItem('perk_active_ranger') === 'true') {
            bonusValue += 15;
            bonusBreakdown.push('Ranger +15%');
          }
        }
        if (skillId === 'sneak') {
          if (localStorage.getItem('perk_active_ghost') === 'true') {
            bonusValue += 20;
            bonusBreakdown.push('Ghost +20%');
          }
        }
        if (skillId === 'unarmed') {
          if (localStorage.getItem('perk_active_drunken_master') === 'true') {
            bonusValue += 20;
            bonusBreakdown.push('Drunken Master +20%');
          }
        }
        
        const displayValue = skillValue + bonusValue;
        const skillDisplay = bonusValue > 0 
          ? `<div style="font-weight: bold; color: #a78bfa; font-size: 1.1rem;">${skillValue} <span style="color: #4CAF50;">+${bonusValue}</span> = <span style="color: #FFD700;">${displayValue}%</span></div>`
          : `<div style="font-weight: bold; color: #a78bfa; font-size: 1.1rem;">${displayValue}%</div>`;
        
        const bonusInfo = bonusBreakdown.length > 0 
          ? `<div style="font-size: 0.75rem; color: #4CAF50; margin-top: 3px; line-height: 1.2;">${bonusBreakdown.join(', ')}</div>`
          : '';
        
        return `
          <div style="padding: 8px; background: rgba(255, 255, 255, 0.03); border-radius: 4px; border-left: 2px solid #9333ea;">
            <div style="font-size: 0.9rem; color: var(--muted); margin-bottom: 4px;">${skillName}</div>
            ${skillDisplay}
            ${bonusInfo}
          </div>
        `;
      }).join('');
      
      container.innerHTML = skillsHTML;
    }

    function toggleSkillsAccordion() {
      const container = qs('skills-container');
      const toggle = qs('skills-toggle');
      const isVisible = container.style.display !== 'none';
      
      if (isVisible) {
        container.style.display = 'none';
        toggle.textContent = '‚ñ∂ Show Skills';
      } else {
        container.style.display = 'grid';
        toggle.textContent = '‚ñº Hide Skills';
      }
    }

    function toggleTraitsAccordion() {
      const container = qs('traits-container');
      const toggle = qs('traits-toggle');
      const isVisible = container.style.display !== 'none';
      
      if (isVisible) {
        container.style.display = 'none';
        toggle.textContent = '‚ñ∂ Show Traits';
      } else {
        container.style.display = 'grid';
        toggle.textContent = '‚ñº Hide Traits';
      }
    }

    function togglePerksAccordion() {
      const container = qs('perks-container');
      const toggle = qs('perks-toggle');
      const isVisible = container.style.display !== 'none';
      
      if (isVisible) {
        container.style.display = 'none';
        toggle.textContent = '‚ñ∂ Show Perks';
      } else {
        container.style.display = 'grid';
        toggle.textContent = '‚ñº Hide Perks';
      }
    }

    function toggleEffectsAccordion() {
      const container = qs('effects-container');
      const toggle = qs('effects-toggle');
      const isVisible = container.style.display !== 'none';
      
      if (isVisible) {
        container.style.display = 'none';
        toggle.textContent = '‚ñ∂ Show Status Effects';
      } else {
        container.style.display = 'grid';
        toggle.textContent = '‚ñº Hide Status Effects';
      }
    }

    // function toggleToolsAccordion() {
    //   const container = qs('tools-container');
    //   const toggle = qs('tools-toggle');
    //   const isVisible = container.style.display !== 'none';
      
    //   if (isVisible) {
    //     container.style.display = 'none';
    //     toggle.textContent = '‚ñ∂ Show Tools';
    //   } else {
    //     container.style.display = 'grid';
    //     toggle.textContent = '‚ñº Hide Tools';
    //   }
    // }

    function toggleConditionalPerksAccordion() {
      const container = qs('conditional-perks-container');
      const toggle = qs('conditional-perks-toggle');
      const desc = qs('conditional-perks-desc');
      const isVisible = container.style.display !== 'none';
      
      if (isVisible) {
        container.style.display = 'none';
        desc.style.display = 'none';
        toggle.textContent = '‚ñ∂ Show Conditional Perks';
      } else {
        container.style.display = 'grid';
        desc.style.display = 'block';
        toggle.textContent = '‚ñº Hide Conditional Perks';
      }
    }

    function displayCharacterTraits(selectedTraits) {
      const container = qs('traits-container');
      
      if (!Array.isArray(selectedTraits) || selectedTraits.length === 0) {
        container.innerHTML = '<p style="color: #999; grid-column: 1/-1;">This character has no traits.</p>';
        return;
      }

      // Separate traits into conditional (toggleable) and non-conditional
      const CONDITIONAL_TRAITS = new Set(['night_person', 'sex_appeal']);
      const conditionalTraits = selectedTraits.filter(t => CONDITIONAL_TRAITS.has(t));
      const staticTraits = selectedTraits.filter(t => !CONDITIONAL_TRAITS.has(t));
      
      // Trait color coding
      const traitColors = {
        'night_person': '#06b6d4',
        'sex_appeal': '#ec4899'
      };
      
      let html = '';
      
      // Display static traits
      html += staticTraits.map(trait => {
        const traitDef = (typeof TRAITS !== 'undefined' && TRAITS[trait]) 
          ? TRAITS[trait]
          : null;
        const borderColor = '#f97316'; // orange for passive traits
        
        if (!traitDef) {
          return `
            <div style="padding: 12px; background: rgba(255, 255, 255, 0.03); border-radius: 4px; border-left: 3px solid ${borderColor};">
              <div style="font-weight: bold; color: #fff; padding: 8px; background-color: rgba(255,255,255,0.05); border-radius: 4px; text-align: center; border: 1px solid ${borderColor};">
                ${trait.replace(/_/g, ' ').split(' ').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ')}
              </div>
            </div>
          `;
        }
        
        return `
          <div style="padding: 12px; background: rgba(255, 255, 255, 0.03); border-radius: 4px; border-left: 3px solid ${borderColor};">
            <div style="font-weight: bold; color: #fff; padding: 8px; background-color: rgba(255,255,255,0.05); border-radius: 4px; text-align: center; border: 1px solid ${borderColor};">
              ${traitDef.name}
            </div>
            <div style="font-size: 0.8rem; color: var(--muted); margin-top: 8px; line-height: 1.4;">${traitDef.description}</div>
            ${traitDef.effects ? `<div style="margin-top: 6px; padding-top: 6px; border-top: 1px solid rgba(255,255,255,0.1);"><div style="font-size: 0.7rem; color: #4CAF50; font-weight: bold; margin-bottom: 4px; text-transform: uppercase;">Effects:</div><div style="font-size: 0.75rem; color: #a78bfa;">${traitDef.effects}</div></div>` : ''}
            <div style="margin-top: 6px; font-size: 0.7rem; color: #666; text-transform: uppercase; letter-spacing: 0.5px;">Passive</div>
          </div>
        `;
      }).join('');
      
      // Display conditional traits with toggles
      html += conditionalTraits.map(trait => {
        const traitDef = (typeof TRAITS !== 'undefined' && TRAITS[trait]) 
          ? TRAITS[trait]
          : null;
        const isActive = localStorage.getItem(`trait_active_${trait}`) === 'true';
        const borderColor = traitColors[trait] || '#f97316';
        const traitName = traitDef 
          ? traitDef.name 
          : trait.replace(/_/g, ' ').split(' ').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
        
        const toggleButton = `
          <button 
            type="button"
            onclick="toggleTrait('${trait}')"
            style="width: 100%; padding: 8px; color: white; border: 2px solid ${isActive ? borderColor : '#666'}; background-color: ${isActive ? borderColor : '#666'}; border-radius: 4px; cursor: pointer; font-weight: bold; transition: all 0.2s;"
            title="Toggle ${traitName}"
          >
            ${isActive ? '‚óè ' : '‚óã '}${traitName}
          </button>
        `;
        
        if (!traitDef) {
          return `
            <div style="padding: 12px; background: rgba(255, 255, 255, 0.03); border-radius: 4px; border-left: 3px solid ${borderColor};">
              ${toggleButton}
              <div style="margin-top: 6px; font-size: 0.7rem; color: #666; text-transform: uppercase; letter-spacing: 0.5px;">Conditional</div>
            </div>
          `;
        }
        
        return `
          <div style="padding: 12px; background: rgba(255, 255, 255, 0.03); border-radius: 4px; border-left: 3px solid ${borderColor};">
            ${toggleButton}
            <div style="font-size: 0.8rem; color: var(--muted); margin-top: 8px; line-height: 1.4;">${traitDef.description}</div>
            ${traitDef.effects ? `<div style="margin-top: 6px; padding-top: 6px; border-top: 1px solid rgba(255,255,255,0.1);"><div style="font-size: 0.7rem; color: #4CAF50; font-weight: bold; margin-bottom: 4px; text-transform: uppercase;">Effects:</div><div style="font-size: 0.75rem; color: #a78bfa;">${traitDef.effects}</div></div>` : ''}
            <div style="margin-top: 6px; font-size: 0.7rem; color: #666; text-transform: uppercase; letter-spacing: 0.5px;">Conditional</div>
          </div>
        `;
      }).join('');
      
      container.innerHTML = html;
    }

    function displayPerks(perkEffects) {
      const container = qs('perks-container');
      
      
      if (!perkEffects || Object.keys(perkEffects).length === 0) {
        container.innerHTML = '<p style="color: #999; grid-column: 1/-1;">No perks selected.</p>';
        return;
      }

      const perkList = [];
      
      // HP Bonuses
      if (perkEffects.hpBonusPerLevel) {
        perkList.push({
          name: 'HP Bonus',
          effect: `+${perkEffects.hpBonusPerLevel} HP per level`
        });
      }
      
      // Skill Points Bonus
      if (perkEffects.skillPointsPerLevel) {
        perkList.push({
          name: 'Skill Points',
          effect: `+${perkEffects.skillPointsPerLevel} skill points per level`
        });
      }
      
      // Healing Rate
      if (perkEffects.healingRate) {
        perkList.push({
          name: 'Healing Rate',
          effect: `+${perkEffects.healingRate} healing rate`
        });
      }
      
      // Attribute Bonuses
      if (perkEffects.attributeBonus) {
        Object.entries(perkEffects.attributeBonus).forEach(([attr, bonus]) => {
          if (bonus > 0) {
            const attrName = attr.charAt(0).toUpperCase() + attr.slice(1);
            perkList.push({
              name: `Gain ${attrName}`,
              effect: `+${bonus} to ${attrName}`
            });
          }
        });
      }
      
      // Skill Bonuses
      if (perkEffects.skillBonuses) {
        Object.entries(perkEffects.skillBonuses).forEach(([skill, bonus]) => {
          if (bonus > 0) {
            const skillName = skill.replace(/_/g, ' ').split(' ').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
            perkList.push({
              name: skillName,
              effect: `+${bonus}% ${skillName}`
            });
          }
        });
      }
      
      // Damage Resistance
      if (perkEffects.damageResistance) {
        perkList.push({
          name: 'Damage Resistance',
          effect: `+${perkEffects.damageResistance}% DR`
        });
      }
      
      // Radiation Resistance
      if (perkEffects.radiationResistance) {
        perkList.push({
          name: 'Radiation Resistance',
          effect: `+${perkEffects.radiationResistance}% RR`
        });
      }
      
      // Armor Bonus
      if (perkEffects.armorBonus) {
        perkList.push({
          name: 'Armor Class',
          effect: `+${perkEffects.armorBonus} AC`
        });
      }
      
      // Sequence Bonus
      if (perkEffects.sequenceBonus) {
        perkList.push({
          name: 'Sequence',
          effect: `+${perkEffects.sequenceBonus} to Sequence`
        });
      }
      
      // Tag Skills
      if (perkEffects.additionalTagSkills) {
        perkList.push({
          name: 'Additional Tag Skills',
          effect: `+${perkEffects.additionalTagSkills} tag skill`
        });
      }
      
      // Combat Bonuses
      if (perkEffects.criticalChanceBonus) {
        perkList.push({
          name: 'Critical Chance',
          effect: `+${perkEffects.criticalChanceBonus}% crit chance`
        });
      }
      
      if (perkEffects.criticalDamageMultiplier) {
        perkList.push({
          name: 'Critical Damage',
          effect: `${(perkEffects.criticalDamageMultiplier * 100).toFixed(0)}% crit damage`
        });
      }
      
      if (perkEffects.actionPointBonus) {
        perkList.push({
          name: 'Action Points',
          effect: `+${perkEffects.actionPointBonus} AP in combat`
        });
      }

      if (perkList.length === 0) {
        container.innerHTML = '<p style="color: #999; grid-column: 1/-1;">No perk effects active.</p>';
        return;
      }

      container.innerHTML = perkList.map(perk => `
        <div style="padding: 12px; background: rgba(255, 255, 255, 0.03); border-radius: 4px; border-left: 3px solid #60a5fa;">
          <div style="font-weight: bold; color: #60a5fa; margin-bottom: 4px;">${perk.name}</div>
          <div style="font-size: 0.85rem; color: var(--muted);">${perk.effect}</div>
        </div>
      `).join('');
    }

    // Tools section removed

    const AVAILABLE_EFFECTS = [
      {
        id: 'radiated',
        name: 'Radiated',
        description: 'Exposed to radiation. Slowly losing HP.',
        color: '#4ade80'
      },
      {
        id: 'poisoned',
        name: 'Poisoned',
        description: 'Toxin in your system. Damage over time.',
        color: '#a855f7'
      },
      {
        id: 'dazed',
        name: 'Dazed',
        description: 'Disoriented. Reduced perception and accuracy.',
        color: '#fbbf24'
      },
      {
        id: 'confused',
        name: 'Confused',
        description: 'Mind is unclear. May act unpredictably.',
        color: '#f97316'
      },
      {
        id: 'crippled',
        name: 'Crippled',
        description: 'Limb is damaged. Movement severely reduced.',
        color: '#ef4444'
      },
      {
        id: 'bleeding',
        name: 'Bleeding',
        description: 'Wound is open and bleeding. Lose HP each turn.',
        color: '#dc2626'
      },
      {
        id: 'on_fire',
        name: 'On Fire',
        description: 'Burning! Take fire damage each turn.',
        color: '#ff6b35'
      },
      {
        id: 'electrified',
        name: 'Electrified',
        description: 'Charged with electricity. Shocking to the touch.',
        color: '#3b82f6'
      },
      {
        id: 'blinded',
        name: 'Blinded',
        description: 'Cannot see. Massive accuracy penalty.',
        color: '#1f2937'
      },
      {
        id: 'deafened',
        name: 'Deafened',
        description: 'Cannot hear. Reduced situational awareness.',
        color: '#6b7280'
      }
    ];

    function displayStatusEffects() {
      const container = qs('effects-container');
      
      const effectsHTML = AVAILABLE_EFFECTS.map(effect => {
        const isActive = localStorage.getItem(`effect_active_${effect.id}`) === 'true';
        
        return `
          <div style="padding: 12px; background: rgba(255, 255, 255, 0.03); border-radius: 4px; border-left: 3px solid ${effect.color};">
            <button 
              type="button"
              onclick="toggleEffect('${effect.id}')"
              style="width: 100%; padding: 8px; color: white; border: 2px solid ${isActive ? effect.color : '#666'}; background-color: ${isActive ? effect.color : '#666'}; border-radius: 4px; cursor: pointer; font-weight: bold; transition: all 0.2s;"
              title="Toggle ${effect.name}"
            >
              ${isActive ? '‚óè ' : '‚óã '}${effect.name}
            </button>
            <div style="font-size: 0.8rem; color: var(--muted); margin-top: 8px; line-height: 1.4;">${effect.description}</div>
          </div>
        `;
      }).join('');
      
      container.innerHTML = effectsHTML;
    }

    function toggleEffect(effectId) {
      const isActive = localStorage.getItem(`effect_active_${effectId}`) === 'true';
      const newActive = !isActive;
      localStorage.setItem(`effect_active_${effectId}`, newActive);
      
      // Re-render effects to update button states
      displayStatusEffects();
      
      // Re-calculate attributes and skills if needed
      updateGameAttributeDisplay();
    }

    function displayPerks(perkEffects) {
      const container = qs('perks-container');
      
      
      if (!perkEffects || Object.keys(perkEffects).length === 0) {
        container.innerHTML = '<p style="color: #999; grid-column: 1/-1;">No perks selected.</p>';
        return;
      }

      const perkList = [];
      
      // HP Bonuses
      if (perkEffects.hpBonusPerLevel) {
        perkList.push({
          name: 'HP Bonus',
          effect: `+${perkEffects.hpBonusPerLevel} HP per level`
        });
      }
      
      // Skill Points Bonus
      if (perkEffects.skillPointsPerLevel) {
        perkList.push({
          name: 'Skill Points',
          effect: `+${perkEffects.skillPointsPerLevel} skill points per level`
        });
      }
      
      // Healing Rate
      if (perkEffects.healingRate) {
        perkList.push({
          name: 'Healing Rate',
          effect: `+${perkEffects.healingRate} healing rate`
        });
      }
      
      // Attribute Bonuses
      if (perkEffects.attributeBonus) {
        Object.entries(perkEffects.attributeBonus).forEach(([attr, bonus]) => {
          if (bonus > 0) {
            const attrName = attr.charAt(0).toUpperCase() + attr.slice(1);
            perkList.push({
              name: `Gain ${attrName}`,
              effect: `+${bonus} to ${attrName}`
            });
          }
        });
      }
      
      // Skill Bonuses
      if (perkEffects.skillBonuses) {
        Object.entries(perkEffects.skillBonuses).forEach(([skill, bonus]) => {
          if (bonus > 0) {
            const skillName = skill.replace(/_/g, ' ').split(' ').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
            perkList.push({
              name: skillName,
              effect: `+${bonus}% ${skillName}`
            });
          }
        });
      }
      
      // Damage Resistance
      if (perkEffects.damageResistance) {
        perkList.push({
          name: 'Damage Resistance',
          effect: `+${perkEffects.damageResistance}% DR`
        });
      }
      
      // Radiation Resistance
      if (perkEffects.radiationResistance) {
        perkList.push({
          name: 'Radiation Resistance',
          effect: `+${perkEffects.radiationResistance}% RR`
        });
      }
      
      // Armor Bonus
      if (perkEffects.armorBonus) {
        perkList.push({
          name: 'Armor Class',
          effect: `+${perkEffects.armorBonus} AC`
        });
      }
      
      // Sequence Bonus
      if (perkEffects.sequenceBonus) {
        perkList.push({
          name: 'Sequence',
          effect: `+${perkEffects.sequenceBonus} to Sequence`
        });
      }
      
      // Tag Skills
      if (perkEffects.additionalTagSkills) {
        perkList.push({
          name: 'Additional Tag Skills',
          effect: `+${perkEffects.additionalTagSkills} tag skill`
        });
      }
      
      // Combat Bonuses
      if (perkEffects.criticalChanceBonus) {
        perkList.push({
          name: 'Critical Chance',
          effect: `+${perkEffects.criticalChanceBonus}% crit chance`
        });
      }
      
      if (perkEffects.criticalDamageMultiplier) {
        perkList.push({
          name: 'Critical Damage',
          effect: `${(perkEffects.criticalDamageMultiplier * 100).toFixed(0)}% crit damage`
        });
      }
      
      if (perkEffects.actionPointBonus) {
        perkList.push({
          name: 'Action Points',
          effect: `+${perkEffects.actionPointBonus} AP in combat`
        });
      }

      if (perkList.length === 0) {
        container.innerHTML = '<p style="color: #999; grid-column: 1/-1;">No perk effects active.</p>';
        return;
      }

      container.innerHTML = perkList.map(perk => `
        <div style="padding: 12px; background: rgba(255, 255, 255, 0.03); border-radius: 4px; border-left: 3px solid #60a5fa;">
          <div style="font-weight: bold; color: #60a5fa; margin-bottom: 4px;">${perk.name}</div>
          <div style="font-size: 0.85rem; color: var(--muted);">${perk.effect}</div>
        </div>
      `).join('');
    }
    
    const CONDITIONAL_PERK_IDS = new Set([
      // Conditional Stat/Reaction Boosters
      'presence',           // +1 CHR for reaction rolls (dialogue only)
      'brown_noser',        // +1 CHR for reaction rolls with authority figures
      
      // Conditional Skill Bonuses
      'smooth_talker',      // +5% Speech per rank (condition: smooth-talking rolls)
      'survivalist',        // +25% Outdoorsman per rank (condition: specific situations)
      'ranger',             // +15% Outdoorsman (condition: special encounters)
      'ghost',              // +20% Sneak (condition: darkness or at night)
      'drunken_master',     // +20% Unarmed (condition: when drunk)
      
      // Conditional Defensive/Healing Perks
      'die_hard',           // +10% DR when HP < 20%
      'bonus_hth_attacks',  // -1 AP cost for melee (combat specific)
      
      // Conditional Damage/Combat Perks
      'pyromaniac',         // +5 damage with fire weapons (weapon type condition)
      'silent_death',       // Double damage sneaking/behind with melee
      'slayer',             // HtH/melee + luck check = crit
      'sniper'              // Ranged + luck check = crit
    ]);

    // Adrenaline Rush is auto-managed based on HP, not user-toggleable
    const AUTO_MANAGED_PERKS = new Set(['adrenaline_rush']);

    function renderConditionalPerks(selectedPerks) {
      const container = qs('conditional-perks-container');
      
      
      // Descriptions for conditional perks
      const conditionalPerkDescriptions = {
        'presence': '+1 CHR for reaction rolls (dialogue only)',
        'brown_noser': '+1 CHR with authority figures',
        'smooth_talker': '+5% Speech per rank',
        'survivalist': '+25% Outdoorsman per rank',
        'ranger': '+15% Outdoorsman',
        'ghost': '+20% Sneak (darkness/night)',
        'drunken_master': '+20% Unarmed (when drunk)',
        'die_hard': '+10% DR when HP < 20%',
        'bonus_hth_attacks': '-1 AP cost for melee',
        'pyromaniac': '+5 damage with fire weapons',
        'silent_death': 'Double damage sneaking/behind',
        'slayer': 'HtH/melee + luck check = crit',
        'sniper': 'Ranged + luck check = crit'
      };
      
      // Filter to only conditional perks that have been selected (exclude auto-managed perks)
      const conditionalPerks = Array.isArray(selectedPerks) 
        ? selectedPerks.filter(perk => {
            const isConditional = perk && perk.id && CONDITIONAL_PERK_IDS.has(perk.id) && !AUTO_MANAGED_PERKS.has(perk.id);
            return isConditional;
          })
        : [];
      
      
      if (conditionalPerks.length === 0) {
        container.innerHTML = '<p style="color: #999; grid-column: 1/-1;">No conditional perks selected.</p>';
        return;
      }

      container.innerHTML = conditionalPerks.map(perk => {
        // Get perk name from PERKS definition if available, otherwise use id
        const perkName = (typeof PERKS !== 'undefined' && PERKS[perk.id]) 
          ? PERKS[perk.id].name 
          : perk.id.replace(/_/g, ' ').split(' ').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
        
        const perkDesc = conditionalPerkDescriptions[perk.id] || 'Conditional perk';
        
        const isActive = localStorage.getItem(`perk_active_${perk.id}`) === 'true';
        const buttonStyle = isActive 
          ? 'background-color: #4CAF50; border-color: #4CAF50;'
          : 'background-color: #666; border-color: #666;';
        
        return `
          <div style="padding: 12px; background: rgba(255, 255, 255, 0.03); border-radius: 4px; border-left: 3px solid #8b5cf6;">
            <button 
              type="button"
              onclick="toggleConditionalPerk('${perk.id}', this)"
              style="width: 100%; padding: 8px; color: white; border: 2px solid; border-radius: 4px; cursor: pointer; font-weight: bold; transition: all 0.2s; ${buttonStyle}"
              title="Toggle ${perkName} perk"
            >
              ${perkName}
            </button>
            <div style="font-size: 0.8rem; color: var(--muted); margin-top: 6px; line-height: 1.3;">${perkDesc}</div>
          </div>
        `;
      }).join('');
    }

    function renderGameSelectedPerks(selectedPerks) {
      
      try {
        const container = qs('perks-container');
        
        if (!container) {
          return;
        }
        
        if (!Array.isArray(selectedPerks) || selectedPerks.length === 0) {
          container.innerHTML = '<p style="color: #999; grid-column: 1/-1;">No perks selected.</p>';
          return;
        }

        
        // Detailed perk information
        const perkDetails = {
          'action_boy_girl': {
            description: 'Make the most of every moment in combat.',
            effects: ['+1 Action Point per rank']
          },
          'adrenaline_rush': {
            description: 'Fear of death makes you stronger when wounded.',
            effects: ['When HP < 50% of max: +1 Strength']
          },
          'animal_friend': {
            description: 'Animals see you as one of their own.',
            effects: ['Animals will not attack unless threatened or attacked first']
          },
          'awareness': {
            description: 'You always know what\'s going on in a fight.',
            effects: ['See exact HP of enemies when examined', 'Identify equipped weapons on enemies']
          },
          'better_criticals': {
            description: 'Your critical hits are especially brutal.',
            effects: ['Critical hits deal 150% damage', 'Chance to damage a limb increased by 50%']
          },
          'bluff_master': {
            description: 'You can talk your way out of trouble.',
            effects: ['Auto-talk your way out when caught stealing']
          },
          'bone_head': {
            description: 'Your skull is remarkably hard.',
            effects: ['Rank 1: 50% chance to avoid KO', 'Rank 2: 75% chance to avoid KO']
          },
          'bonsai': {
            description: 'You have a fruit tree growing from your head.',
            effects: ['Steady supply of healing fruit', 'You get one healing fruit every session']
          },
          'bonus_hth_attacks': {
            description: 'You can make more melee attacks per turn.',
            effects: ['HtH and melee attacks cost 1 less AP']
          },
          'bonus_hth_damage': {
            description: 'You hit harder in close combat.',
            effects: ['+2 Melee Damage per rank']
          },
          'bonus_move': {
            description: 'You move farther for free.',
            effects: ['For every rank, the first 2 hexes of movement each turn cost 0 AP']
          },
          'bonus_ranged_damage': {
            description: 'You do extra damage with ranged weapons.',
            effects: ['+2 damage per bullet per rank']
          },
          'bonus_rate_of_fire': {
            description: 'Your trigger finger is fast.',
            effects: ['All ranged weapon attacks cost 1 less AP']
          },
          'bracing': {
            description: 'You know how to brace big weapons.',
            effects: ['Gain +10% to-hit bonus when standing and bracing large weapons']
          },
          'brown_noser': {
            description: 'You\'re good at sucking up to authority.',
            effects: ['+1 Charisma for authority figures per rank', 'Max 2 ranks']
          },
          'brutish_hulk': {
            description: 'You gain extra HP per level. (Deathclaw only)',
            effects: ['Double the normal HP gained per level']
          },
          'cancerous_growth': {
            description: 'Radiation has made you hardy. (Ghoul only)',
            effects: ['+2 Healing Rate', 'Regenerate crippled limb in 48 hours']
          },
          'cautious_nature': {
            description: 'You\'re careful in strange situations.',
            effects: ['+3 Perception when determining starting position']
          },
          'comprehension': {
            description: 'You get more out of reading.',
            effects: ['Books grant +50% more skill points']
          },
          'crazy_bomber': {
            description: 'You\'re unnaturally safe with explosives.',
            effects: ['If you fail to set explosive, know instantly', 'Can reset and retry']
          },
          'cult_of_personality': {
            description: 'Everyone likes you, regardless of karma.',
            effects: ['Karma modifiers for reactions always positive', 'Charisma must be 10']
          },
          'death_sense': {
            description: 'You see well in darkness and sense danger. (Deathclaw only)',
            effects: ['+2 Perception in dark', 'Light penalties reduced 50%']
          },
          'demolition_expert': {
            description: 'You\'re a professional with explosives.',
            effects: ['Explosives deal +50% damage', 'Always detonate on time']
          },
          'die_hard': {
            description: 'You stay up when others drop.',
            effects: ['When HP < 20%: +10% Damage Resistance (all types)']
          },
          'divine_favor': {
            description: 'A higher power watches over you.',
            effects: ['Once per 24 hours, re-roll any failed roll', 'Must accept second result']
          },
          'dodger': {
            description: 'You\'re harder to hit.',
            effects: ['+5 Armor Class per rank']
          },
          'drunken_master': {
            description: 'You fight better when drunk.',
            effects: ['+20% Unarmed when intoxicated']
          },
          'earlier_sequence': {
            description: 'You move earlier in combat rounds.',
            effects: ['+2 Sequence per rank', 'Max 3 ranks']
          },
          'educated': {
            description: 'You learn more per level.',
            effects: ['+2 skill points per level per rank']
          },
          'empathy': {
            description: 'You get a read on people.',
            effects: ['GM warns when dialogue will be negative', 'Better dialogue choices']
          },
          'explorer': {
            description: 'You find strange and interesting things.',
            effects: ['Increased chance for special encounters', 'Find more unique items']
          },
          'faster_healing': {
            description: 'You heal more quickly.',
            effects: ['+2 Healing Rate per rank']
          },
          'flexible': {
            description: 'You change stances quickly.',
            effects: ['Changing combat stance costs 1 AP']
          },
          'flower_child': {
            description: 'You\'re less affected by chems.',
            effects: ['50% less likely to become addicted', 'Withdrawal time is half normal']
          },
          'fortune_finder': {
            description: 'You find more money.',
            effects: ['Looting yields more currency']
          },
          'gambler': {
            description: 'You\'re notably good at games of chance.',
            effects: ['One-time +20% to Gambling']
          },
          'ghost': {
            description: 'You\'re nearly invisible in the dark.',
            effects: ['+20% Sneak in darkness or at night']
          },
          'gunner': {
            description: 'You\'re good at firing from moving vehicles.',
            effects: ['No 10% penalty for shooting from moving vehicles']
          },
          'harmless': {
            description: 'You look too innocent to be a thief.',
            effects: ['+20% Steal', 'Good karma required']
          },
          'healer': {
            description: 'You heal more HP with medical skills.',
            effects: ['Rank 1: +1d6+4 HP healed', 'Rank 2: +2√ó(1d6+4) HP healed']
          },
          'heave_ho': {
            description: 'You throw weapons farther.',
            effects: ['Strength treated as +2 per rank for thrown weapon range']
          },
          'hide_of_scars': {
            description: 'Your scarred hide is its own armor. (Deathclaw only)',
            effects: ['+15% all resistances(except fire) per rank']
          },
          'hit_the_deck': {
            description: 'You react quickly to explosives.',
            effects: ['Take half damage from ranged explosive weapons']
          },
          'hth_evade': {
            description: 'Your unarmed stance improves your defense.',
            effects: ['Gain 3 AC per unused AP if not holding weapons at end of turn']
          },
          'kama_sutra_master': {
            description: 'You are exceptionally skilled in intimate matters.',
            effects: ['Great stamina and skill', 'Roleplay effect']
          },
          'karma_beacon': {
            description: 'Your karma radiates outward.',
            effects: ['Karma is doubled for reaction purposes']
          },
          'leader': {
            description: 'You inspire your party.',
            effects: ['Party within 10 hexes: +1 Agility, +5 AC (not leader)']
          },
          'lifegiver': {
            description: 'You gain extra HP on level up.',
            effects: ['+4 HP per level per rank']
          },
          'light_step': {
            description: 'You avoid triggers and traps.',
            effects: ['+4 effective Agility', 'For trap triggering checks']
          },
          'living_anatomy': {
            description: 'You understand where to hurt people.',
            effects: ['+10% Doctor', '+5 damage vs. living creatures']
          },
          'loner': {
            description: 'You operate better alone.',
            effects: ['+10% all skill rolls when 10+ hexes from party']
          },
          'master_thief': {
            description: 'You are a consummate thief.',
            effects: ['One-time +15% to Lockpick', 'One-time +15% to Steal']
          },
          'master_trader': {
            description: 'You are exceptionally good at trading.',
            effects: ['One-time +30% to Barter']
          },
          'medic': {
            description: 'You are well-trained in medicine.',
            effects: ['One-time +10% to First Aid', 'One-time +10% to Doctor']
          },
          'mental_block': {
            description: 'You can tune out unwanted mental interference.',
            effects: ['Perception treated as +1 for combat range and trap detection']
          },
          'more_criticals': {
            description: 'You cause critical hits more often.',
            effects: ['+5% Critical Chance per rank']
          },
          'mr_fixit': {
            description: 'You excel at technical work.',
            effects: ['One-time +10% to Repair', 'One-time +10% to Science']
          },
          'mysterious_stranger': {
            description: 'A strange ally sometimes appears.',
            effects: ['30% + (2 √ó Luck)% chance to gain a Temporary ally in random encounters']
          },
          'negotiator': {
            description: 'You\'re better at getting deals and persuading.',
            effects: ['One-time +10% to Speech', 'One-time +10% to Barter']
          },
          'night_vision': {
            description: 'You see better in the dark.',
            effects: ['Light penalties reduced by 50% in darkness']
          },
          'pack_rat': {
            description: 'You can carry more gear.',
            effects: ['+10 lbs Carry Weight per rank']
          },
          'pathfinder': {
            description: 'You travel more efficiently.',
            effects: ['Overland travel time reduced by 25%']
          },
          'pickpocket': {
            description: 'You\'re very skilled at lifting items.',
            effects: ['+25% Steal when stealing from Characters/NPCs']
          },
          'presence': {
            description: 'Your presence influences reactions.',
            effects: ['+1 Charisma for reaction rolls per rank']
          },
          'psychotic': {
            description: 'You\'ve adapted to Psycho. (Mutant only)',
            effects: ['Positive Psycho effects doubled', 'Addiction rate halved']
          },
          'pyromaniac': {
            description: 'You do terrible things with fire.',
            effects: ['+5 damage with fire-based weapons']
          },
          'quick_pockets': {
            description: 'You swap gear faster.',
            effects: ['Swapping equipment costs 2 AP instead of 4 in combat']
          },
          'quick_recovery': {
            description: 'You get up faster.',
            effects: ['Standing up from knockdown costs 1 AP']
          },
          'rad_child': {
            description: 'Radiation heals you instead of harming you. (Ghoul only)',
            effects: ['When in 10+ rads/hour source: +5 Healing Rate']
          },
          'rad_resistance': {
            description: 'You resist radiation better.',
            effects: ['+15% Radiation Resistance per rank']
          },
          'ranger': {
            description: 'You\'re a seasoned wanderer.',
            effects: ['One-time +15% Outdoorsman', 'Special encounters easier to find']
          },
          'road_warrior': {
            description: 'You can drive and fight at the same time.',
            effects: ['No penalties when driving and attacking simultaneously']
          },
          'salesman': {
            description: 'You\'re good at selling things.',
            effects: ['One-time +20% to Barter']
          },
          'scout': {
            description: 'You see farther and find more.',
            effects: ['Increased world map vision', 'Special items easier to find']
          },
          'scrounger': {
            description: 'You find more ammunition.',
            effects: ['Always find double the normal amount of ammo']
          },
          'sharpshooter': {
            description: 'You\'re better at long-range shooting.',
            effects: ['Perception treated as +2 for range modifiers']
          },
          'silent_death': {
            description: 'You excel at killing from the shadows.',
            effects: ['Deal double damage while sneaking and attacking from behind with HtH/melee']
          },
          'silent_running': {
            description: 'You can run while sneaking.',
            effects: ['Run and sneak at the same time']
          },
          'slayer': {
            description: 'You are a walking melee death machine.',
            effects: ['Successful attack + successful Luck check = critical hit with HtH/melee']
          },
          'smooth_talker': {
            description: 'You sound smarter than you are.',
            effects: ['+1 Intelligence for "smooth-talking" dialogue checks per rank']
          },
          'snakeater': {
            description: 'You shrug off poison.',
            effects: ['+25% Poison Resistance']
          },
          'sniper': {
            description: 'Your shots tend to be critical.',
            effects: ['Successful ranged attack + successful Luck check = critical hit']
          },
          'speaker': {
            description: 'You\'re especially persuasive.',
            effects: ['One-time +20% to Speech']
          },
          'stat': {
            description: 'You\'re faster at battlefield medicine.',
            effects: ['Using First Aid/Doctor in combat costs 5 AP']
          },
          'steady_arm': {
            description: 'You handle burst fire better. (Mutant only)',
            effects: ['Burst attacks cost 1 less AP']
          },
          'stonewall': {
            description: 'You are hard to knock down.',
            effects: ['50% chance to avoid knockdown']
          },
          'strong_back': {
            description: 'You can carry significantly more.',
            effects: ['+50 lbs Carry Weight per rank']
          },
          'stunt_devil': {
            description: 'You handle impacts better.',
            effects: ['25% less damage from falls', 'Vehicle wreck damage reduced', 'One-time +10% Pilot']
          },
          'survivalist': {
            description: 'You\'re excellent at survival.',
            effects: ['+25% Outdoorsman per rank']
          },
          'talon_of_fear': {
            description: 'Your claws are venomous. (Deathclaw only)',
            effects: ['All unarmed attacks inflict Type B poison']
          },
          'team_player': {
            description: 'You work best with the group.',
            effects: ['When all party within 10 hexes: +10% for all skills']
          },
          'thief': {
            description: 'You are broadly skilled in thievery.',
            effects: ['One-time +10% to Sneak, Lockpick, Steal, and Traps']
          },
          'tough_hide': {
            description: 'Your hide is hardened by the wastes. (Mutant only)',
            effects: ['+15 Armor Class; +10% all resistances per rank']
          },
          'toughness': {
            description: 'You are naturally more resilient.',
            effects: ['+10% Damage Resistance to all damage types']
          },
          'tunnel_rat': {
            description: 'You move quickly while low.',
            effects: ['Normal movement rate while crouching or prone (1 AP per hex)']
          },
          'way_of_the_fruit': {
            description: 'Fruit has mystical effects on you.',
            effects: ['For 24 hours after eating fruit: +1 Perception and +1 Agility']
          },
          'weapon_handling': {
            description: 'You handle heavy weapons more easily.',
            effects: ['+3 effective Strength for meeting weapon requirements']
          }
        };

        const perkHTML = selectedPerks.map((perk, idx) => {
          const perkId = perk.id || perk;
          const perkRank = perk.rank || 1;
          
          const isConditional = CONDITIONAL_PERK_IDS.has(perkId);
          const isAutoManaged = AUTO_MANAGED_PERKS.has(perkId);
          
          // Format perk name
          let perkName = perkId.replace(/_/g, ' ').split(' ').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
          const rankBadge = `<span style="background: rgba(255,255,255,0.2); padding: 2px 6px; border-radius: 3px; font-size: 0.85em; margin-left: 6px;">Rank ${perkRank}</span>`;
          
          // Get detailed description and effects
          const details = perkDetails[perkId] || {
            description: 'Perk effect',
            effects: []
          };
          
          // Determine styling based on perk type
          let borderColor = '#60a5fa'; // Default: blue for unconditional/passive
          let typeLabel = 'Passive';
          let showToggle = false;
          
          if (isAutoManaged) {
            borderColor = '#ef4444'; // red
            typeLabel = 'Auto-Active';
          } else if (isConditional) {
            borderColor = '#8b5cf6'; // purple
            typeLabel = 'Conditional';
            showToggle = true;
          }
          
          
          // Build toggle button or static display
          let toggleButton;
          if (showToggle) {
            // Conditional perks with manual toggle
            const isActive = localStorage.getItem(`perk_active_${perkId}`) === 'true';
            toggleButton = `
              <button 
                type="button"
                onclick="toggleConditionalPerk('${perkId}', this)"
                style="width: 100%; padding: 8px; color: white; border: 2px solid ${isActive ? borderColor : '#666'}; background-color: ${isActive ? borderColor : '#666'}; border-radius: 4px; cursor: pointer; font-weight: bold; transition: all 0.2s;"
                title="Toggle ${perkName}"
              >
                ${isActive ? '‚óè ' : '‚óã '}${perkName}${rankBadge}
              </button>
            `;
          } else if (isAutoManaged) {
            // Auto-managed perks showing their current state
            const isActive = localStorage.getItem(`perk_active_${perkId}`) === 'true';
            const displayColor = isActive ? borderColor : '#666';
            toggleButton = `
              <div style="font-weight: bold; color: #fff; padding: 8px; background-color: ${displayColor}; border-radius: 4px; text-align: center; border: 1px solid ${displayColor}; transition: all 0.2s;">
                ${isActive ? '‚óè ' : '‚óã '}${perkName}${rankBadge}
              </div>
            `;
          } else {
            // Passive perks with static display
            toggleButton = `
              <div style="font-weight: bold; color: #fff; padding: 8px; background-color: rgba(255,255,255,0.05); border-radius: 4px; text-align: center; border: 1px solid ${borderColor};">
                ${perkName}${rankBadge}
              </div>
            `;
          }
          
          // Build effects list
          const effectsList = details.effects.length > 0
            ? `<div style="margin-top: 6px; padding-top: 6px; border-top: 1px solid rgba(255,255,255,0.1);">
                 <div style="font-size: 0.7rem; color: #4CAF50; font-weight: bold; margin-bottom: 4px; text-transform: uppercase;">Effects:</div>
                 <ul style="margin: 0; padding-left: 16px; font-size: 0.75rem; color: #a78bfa; line-height: 1.5;">
                   ${details.effects.map(effect => `<li>${effect}</li>`).join('')}
                 </ul>
               </div>`
            : '';
          
          return `
            <div style="padding: 12px; background: rgba(255, 255, 255, 0.03); border-radius: 4px; border-left: 3px solid ${borderColor};">
              ${toggleButton}
              <div style="font-size: 0.8rem; color: var(--muted); margin-top: 8px; line-height: 1.4;">${details.description}</div>
              ${effectsList}
              <div style="margin-top: 6px; font-size: 0.7rem; color: #666; text-transform: uppercase; letter-spacing: 0.5px;">${typeLabel}</div>
            </div>
          `;
        }).join('');

        container.innerHTML = perkHTML;
      } catch (err) {
      }
    }

    function toggleConditionalPerk(perkId, buttonElement) {
      const isActive = localStorage.getItem(`perk_active_${perkId}`) === 'true';
      const newActive = !isActive;
      
      
      localStorage.setItem(`perk_active_${perkId}`, newActive);
      
      
      // Update button styling
      if (newActive) {
        buttonElement.style.backgroundColor = '#4CAF50';
        buttonElement.style.borderColor = '#4CAF50';
        buttonElement.textContent = '‚óè ' + buttonElement.textContent.slice(2);
      } else {
        buttonElement.style.backgroundColor = '#666';
        buttonElement.style.borderColor = '#666';
        buttonElement.textContent = '‚óã ' + buttonElement.textContent.slice(2);
      }
      
      // Re-calculate attributes and skills with new perk active/inactive state
      updateGameAttributeDisplay();
    }

    function toggleTrait(traitId) {
      const isActive = localStorage.getItem(`trait_active_${traitId}`) === 'true';
      const newActive = !isActive;
      
      
      localStorage.setItem(`trait_active_${traitId}`, newActive);
      
      
      // Re-render traits to update button state
      const stored = localStorage.getItem('characterData');
      if (stored) {
        try {
          const characterData = JSON.parse(stored);
          displayCharacterTraits(characterData.selectedTraits || []);
          
          // Re-calculate attributes and skills with new trait active/inactive state
          updateGameAttributeDisplay();
        } catch (err) {
        }
      }
    }

    function decreaseHP() {
      const stored = localStorage.getItem('characterData');
      const characterData = JSON.parse(stored);
      const maxHealthHP = characterData.stats?.Hit_Points || 15;
      
      let currentHP = parseInt(localStorage.getItem('currentHP'));
      if (currentHP === null) currentHP = maxHealthHP;
      const newHP = Math.max(0, currentHP - 1);
      localStorage.setItem('currentHP', newHP);
      
      renderHealthTracker(newHP, maxHealthHP);
      updateAdrenalineRush(newHP);
      updateGameAttributeDisplay();
      renderGameSelectedPerks(characterData.selectedPerks || []);
    }

    function increaseHP() {
      const stored = localStorage.getItem('characterData');
      const characterData = JSON.parse(stored);
      const maxHealthHP = characterData.stats?.Hit_Points || 15;
      
      let currentHP = parseInt(localStorage.getItem('currentHP'));
      if (currentHP === null || isNaN(currentHP)) currentHP = maxHealthHP;
      const newHP = Math.min(maxHealthHP, currentHP + 1);
      localStorage.setItem('currentHP', newHP);
      
      renderHealthTracker(newHP, maxHealthHP);
      updateAdrenalineRush(newHP);
      updateGameAttributeDisplay();
      renderGameSelectedPerks(characterData.selectedPerks || []);
    }

    function updateAdrenalineRush(currentHP) {
      // Adrenaline Rush auto-activates when HP < 50% of max, but only if the character has the perk
      const stored = localStorage.getItem('characterData');
      if (!stored) return;
      
      try {
        const characterData = JSON.parse(stored);
        const selectedPerks = characterData.selectedPerks || [];
        const hasAdrenalineRush = Array.isArray(selectedPerks) && selectedPerks.some(perk => perk && perk.id === 'adrenaline_rush');
        
        // Only allow Adrenaline Rush to be active if character has the perk
        if (!hasAdrenalineRush) {
          localStorage.setItem('perk_active_adrenaline_rush', 'false');
          return;
        }
        
        const threshold = maxHP / 2;
        const shouldBeActive = currentHP < threshold;
        const isActive = localStorage.getItem('perk_active_adrenaline_rush') === 'true';
        
        if (shouldBeActive && !isActive) {
          localStorage.setItem('perk_active_adrenaline_rush', 'true');
        } else if (!shouldBeActive && isActive) {
          localStorage.setItem('perk_active_adrenaline_rush', 'false');
        }
      } catch (err) {
      }
    }

    function updateGameAttributeDisplay() {
      const stored = localStorage.getItem('characterData');
      if (!stored) return;
      
      try {
        const characterData = JSON.parse(stored);
        const attrs = characterData.attributes || {};
        const selectedTraits = characterData.selectedTraits || [];
        const currentHP = parseInt(localStorage.getItem('currentHP')) || maxHP;
        
        let strength = parseInt(attrs.strength) || 0;
        let perception = parseInt(attrs.perception) || 0;
        let endurance = parseInt(attrs.endurance) || 0;
        let charisma = parseInt(attrs.charisma) || 0;
        let intelligence = parseInt(attrs.intelligence) || 0;
        let agility = parseInt(attrs.agility) || 0;
        let luck = parseInt(attrs.luck) || 0;
        
        
        // Apply conditional attribute bonuses from perks
        if (localStorage.getItem('perk_active_adrenaline_rush') === 'true' && currentHP < maxHP / 2) {
          strength += 1;
        }
        if (localStorage.getItem('perk_active_presence') === 'true') {
          charisma += 1;
        }
        if (localStorage.getItem('perk_active_brown_noser') === 'true') {
          charisma += 1;
        }
        
        // Apply trait bonuses - Night Person (check if explicitly true)
        if (selectedTraits.includes('night_person') && localStorage.getItem('trait_active_night_person') === 'true') {
          intelligence += 1; // +1 INT at night
          perception += 1;   // +1 PER at night
        } else if (selectedTraits.includes('night_person')) {
        }
        
        // Apply trait bonuses - Sex Appeal (check if explicitly true)
        if (selectedTraits.includes('sex_appeal') && localStorage.getItem('trait_active_sex_appeal') === 'true') {
          charisma += 1; // +1 CHA with opposite sex
        } else if (selectedTraits.includes('sex_appeal')) {
        }
        
        
        qs('attr-str').textContent = strength || '‚Äî';
        qs('attr-per').textContent = perception || '‚Äî';
        qs('attr-end').textContent = endurance || '‚Äî';
        qs('attr-chr').textContent = charisma || '‚Äî';
        qs('attr-int').textContent = intelligence || '‚Äî';
        qs('attr-agi').textContent = agility || '‚Äî';
        qs('attr-lck').textContent = luck || '‚Äî';
        
        // Update equipped armor display
        updateEquippedArmorDisplay();
        
        // Update melee damage display
        updateMeleeDamageDisplay(strength);
        
        renderSkills(characterData.skills || {}, characterData);
      } catch (err) {
      }
    }

    function updateEquippedArmorDisplay() {
      const armorDisplay = qs('char-equipped-armor');
      const armorClassDisplay = qs('char-armor-class');
      const savedSelection = localStorage.getItem('equipmentItemSelection');
      const stored = localStorage.getItem('characterData');
      
      // Get base AC from character stats
      let baseAC = 0;
      if (stored) {
        try {
          const characterData = JSON.parse(stored);
          baseAC = parseInt(characterData.stats?.Armor_Class) || 0;
        } catch (e) {
          console.log('Could not parse character data for AC');
        }
      }
      
      try {
        if (savedSelection) {
          const selection = JSON.parse(savedSelection);
          if (selection && selection[2] && selection[2].name) {
            armorDisplay.textContent = selection[2].name;
            
            // Extract armor bonus and calculate total AC
            const armorStats = ITEM_STATS[selection[2].name];
            let armorBonus = 0;
            
            if (armorStats && armorStats.armor && armorStats.armor !== '‚Äî') {
              // Parse armor bonus from format like "+2 AC"
              const match = armorStats.armor.match(/([+-]?\d+)/);
              if (match) {
                armorBonus = parseInt(match[1]);
              }
            }
            
            const totalAC = baseAC + armorBonus;
            armorClassDisplay.textContent = totalAC;
            return;
          }
        }
      } catch (e) {
        console.log('Could not parse equipment selection');
      }
      
      armorDisplay.textContent = 'None';
      armorClassDisplay.textContent = baseAC;
    }

    function updateMeleeDamageDisplay(strength) {
      const damageDisplay = qs('char-melee-damage');
      const stored = localStorage.getItem('characterData');
      
      if (!stored) {
        damageDisplay.textContent = '‚Äî';
        return;
      }
      
      try {
        const characterData = JSON.parse(stored);
        const selectedTraits = characterData.selectedTraits || [];
        const selectedPerks = characterData.selectedPerks || [];
        
        // Base melee damage = (Strength - 5) / 2, minimum 1
        let baseMeleeDamage = Math.max(1, Math.floor((strength - 5) / 2));
        let totalBonus = 0;
        
        // Heavy Handed trait: +4 melee damage
        if (selectedTraits.includes('heavy_handed')) {
          totalBonus += 4;
        }
        
        // Bonus HtH Damage perk: +2 melee damage per rank
        if (Array.isArray(selectedPerks)) {
          const bonusHthDamage = selectedPerks.find(p => p && p.id === 'bonus_hth_damage');
          if (bonusHthDamage) {
            const ranks = bonusHthDamage.ranks || 1;
            totalBonus += 2 * ranks;
          }
        }
        
        const totalMeleeDamage = baseMeleeDamage + totalBonus;
        const displayText = totalBonus > 0 
          ? `${baseMeleeDamage}+${totalBonus}=${totalMeleeDamage}`
          : `${totalMeleeDamage}`;
        
        damageDisplay.textContent = displayText;
      } catch (e) {
        damageDisplay.textContent = '‚Äî';
      }
    }

    function loadCharacter() {
      
      const stored = localStorage.getItem('characterData');
      
      if (!stored) {
        alert('No character data found. Please upload a character file.');
        window.location.href = 'index.html';
        return;
      }

      try {
        const characterData = JSON.parse(stored);
        console.log('%c[CHARACTER DATA LOADED]', 'color: #4CAF50; font-weight: bold;', characterData);
        
        // Initialize trait and perk active states to false if not already set
        const selectedTraits = characterData.selectedTraits || [];
        const CONDITIONAL_TRAITS = new Set(['night_person', 'sex_appeal']);
        selectedTraits.forEach(trait => {
          if (CONDITIONAL_TRAITS.has(trait)) {
            if (localStorage.getItem(`trait_active_${trait}`) === null) {
              localStorage.setItem(`trait_active_${trait}`, 'false');
            }
          }
        });
        
        const selectedPerks = characterData.selectedPerks || [];
        selectedPerks.forEach(perk => {
          const perkId = perk.id || perk;
          if (CONDITIONAL_PERK_IDS.has(perkId) && !AUTO_MANAGED_PERKS.has(perkId)) {
            if (localStorage.getItem(`perk_active_${perkId}`) === null) {
              localStorage.setItem(`perk_active_${perkId}`, 'false');
            }
          }
        });
        
        // RECALCULATE LEVEL FROM TOTALXP
        if (characterData.totalXP !== undefined && typeof getLevelFromXP === 'function') {
          const calculatedLevel = getLevelFromXP(characterData.totalXP || 0);
          characterData.level = calculatedLevel;
        }
        
        // Recalculate Sequence to ensure perk/trait bonuses are applied
        if (typeof recalculateSequence === 'function') {
          recalculateSequence(characterData);
        }
        
        // Display character info
        qs('char-name').textContent = characterData.name || 'Unknown';
        // qs('play-name').textContent = (characterData.player && characterData.player.trim()) ? characterData.player : 'Unknown';
        qs('char-race').textContent = characterData.race || 'Human';
        const levelValue = characterData.level || 1;
        qs('char-level').textContent = levelValue;
        
        // Set Action Points
        maxHP = characterData.stats?.Action_Points || 7;
        qs('char-max-hp').textContent = maxHP;
        
        // Set Sequence
        qs('char-sequence').textContent = characterData.stats?.Sequence || 0;
        
        // Set max HP for health tracking
        const maxHealthHP = characterData.stats?.Hit_Points || 15;
        
        // Check if current HP is saved, otherwise use max HP
        let currentHP = localStorage.getItem('currentHP');
        if (currentHP === null) {
          currentHP = maxHealthHP;
          localStorage.setItem('currentHP', currentHP);
        } else {
          currentHP = parseInt(currentHP);
        }
        
        // Initialize Adrenaline Rush state based on current HP
        updateAdrenalineRush(currentHP);
        
        // Build health tracking UI
        renderHealthTracker(currentHP, maxHealthHP);

        // Display traits
        displayCharacterTraits(characterData.selectedTraits || []);

        // Display selected perks (both conditional and unconditional)
        try {
          renderGameSelectedPerks(characterData.selectedPerks || []);
        } catch (e) {
        }

        // Initialize attribute display with conditional bonuses
        updateGameAttributeDisplay();

        // Display skills with conditional bonuses
        renderSkills(characterData.skills || {}, characterData);

        // Display status effects
        displayStatusEffects();

      } catch (err) {
        alert('Error loading character data.');
      }
    }

    function downloadCharacter() {
      const stored = localStorage.getItem('characterData');
      if (!stored) {
        alert('No character data to download.');
        return;
      }

      try {
        const characterData = JSON.parse(stored);
        
        // Include equipment selections if they exist
        const equipmentSelection = localStorage.getItem('equipmentItemSelection');
        if (equipmentSelection) {
          try {
            const selectedItems = JSON.parse(equipmentSelection);
            characterData.gameEquipmentSelection = {
              items: selectedItems,
              activeItemIndex: parseInt(localStorage.getItem('activeItemIndex') || '0'),
              timestamp: new Date().toISOString()
            };
          } catch (e) {
            console.warn('Could not parse equipment selection', e);
          }
        }
        
        // Use consistent filename format across all screens
        const charName = characterData.name || 'character';
        const dateStamp = new Date().toISOString().split('T')[0];
        const filename = `${charName.toLowerCase().replace(/\s+/g, '_')}_${dateStamp}.json`;
        
        const blob = new Blob([JSON.stringify(characterData, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
      } catch (err) {
        alert('Error downloading character.');
      }
    }

    function returnHome() {
      localStorage.removeItem('characterData');
      localStorage.removeItem('currentHP');
      window.location.href = 'index.html';
    }

    function getEquipmentItems() {
      const stored = localStorage.getItem('characterData');
      console.log('[GET EQUIPMENT] Stored data exists:', !!stored);
      
      if (!stored) return [];
      
      try {
        const characterData = JSON.parse(stored);
        console.log('[GET EQUIPMENT] Character data parsed:', {
          hasEquipment: !!characterData.equipment,
          hasItems: !!characterData.equipment?.items,
          itemsCount: Object.keys(characterData.equipment?.items || {}).length
        });
        
        // Check if user has manually configured equipment selection
        const savedSelection = localStorage.getItem('equipmentItemSelection');
        if (savedSelection) {
          try {
            const selection = JSON.parse(savedSelection);
            if (Array.isArray(selection)) {
              // Filter out null values and return actual items that were selected
              const items = selection.filter(item => item !== null);
              console.log('[GET EQUIPMENT] Using saved equipment selection:', items);
              return items;
            }
          } catch (e) {
            console.log('[GET EQUIPMENT] Saved selection invalid, user must configure items');
          }
        }
        
        // If no saved selection exists, return empty array (user must manually configure)
        console.log('[GET EQUIPMENT] No saved selection found, user must configure items');
        return [];
      } catch (err) {
        console.error('[GET EQUIPMENT] Error:', err);
        return [];
      }
    }

    function updateActiveItemDisplay() {
      const activeItemIndex = parseInt(localStorage.getItem('activeItemIndex') || '0');
      const items = getEquipmentItems();
      
      console.log('[EQUIPMENT DEBUG]', { activeItemIndex, items, itemsLength: items.length });
      
      const display = qs('active-item-display');
      const nameElement = qs('active-item-name');
      const swapBtn = qs('swap-btn');
      const reloadBtn = qs('reload-item-btn');
      const useBtn = qs('use-item-btn');
      const targetedBtn = qs('targeted-attack-btn');
      const burstBtn = qs('burst-mode-toggle-btn');
      
      if (items.length === 0) {
        // Default to Punch (index 0) or Kick (index 1)
        const defaultAttacks = ['Punch', 'Kick'];
        const defaultAttack = defaultAttacks[activeItemIndex] || 'Punch';
        nameElement.textContent = defaultAttack;
        swapBtn.style.display = 'inline-block';
        reloadBtn.style.display = 'none';
        targetedBtn.style.display = 'inline-block';
        burstBtn.style.display = 'none';
        localStorage.removeItem('burstModeActive');
        useBtn.textContent = activeItemIndex === 0 ? 'Swing' : 'Strike';
        displayItemDiceTable(defaultAttack);
        return;
      }
      
      if (items.length === 1) {
        nameElement.textContent = items[0].name;
        swapBtn.style.display = 'none';
        displayItemDiceTable(items[0].name);
        // Check if item has ammo and show reload button
        const itemStats = ITEM_STATS[items[0].name];
        if (itemStats) {
          // Check for burst fire capability
          // Format can be: "S X / T Y / B Z" (full), "S X / T Y" (no burst), or "B Z" (burst-only)
          const apParts = itemStats.apCost ? itemStats.apCost.split('/').map(s => s.trim()) : [];
          console.log(`[BURST CHECK] ${items[0].name} - apCost: "${itemStats.apCost}" - Parts:`, apParts, '- Length:', apParts.length);
          
          // Check if weapon has burst mode:
          // - Has 3 parts with valid burst value (S X / T Y / B Z)
          // - OR is burst-only (B X with no slashes)
          const hasBurst = (apParts.length === 3 && apParts[2] && apParts[2] !== '-') ||
                          (apParts.length === 1 && itemStats.apCost && itemStats.apCost.trim().startsWith('B '));
          const isBurstOnly = apParts.length === 1 && itemStats.apCost && itemStats.apCost.trim().startsWith('B ');
          
          console.log(`[BURST CHECK] ${items[0].name} - hasBurst:`, hasBurst, '- isBurstOnly:', isBurstOnly);
          const isBurstMode = localStorage.getItem('burstModeActive') === 'true' && hasBurst;
          
          // For burst-only weapons, automatically enable burst mode
          if (isBurstOnly) {
            localStorage.setItem('burstModeActive', 'true');
          }
          
          // Hide targeted button when in burst mode
          targetedBtn.style.display = isBurstMode || isBurstOnly ? 'none' : 'inline-block';
          
          if (hasBurst) {
            // Only show toggle for weapons with multiple fire modes
            burstBtn.style.display = isBurstOnly ? 'none' : 'inline-block';
            if (!isBurstOnly) {
              updateBurstToggleButton();
            }
          } else {
            burstBtn.style.display = 'none';
            localStorage.removeItem('burstModeActive');
          }
          
          // Determine button text based on weapon type
          const isMeleeOrUnarmed = itemStats.skill === 'Unarmed' || itemStats.skill === 'Melee Weapons';
          
          if (itemStats.ammo && itemStats.ammo !== 'N/A') {
            reloadBtn.style.display = 'inline-block';
            if (isBurstOnly) {
              useBtn.textContent = 'Burst';
            } else {
              useBtn.textContent = isBurstMode ? 'Burst' : 'Fire';
            }
          } else {
            reloadBtn.style.display = 'none';
            useBtn.textContent = isMeleeOrUnarmed ? 'Swing' : 'Use';
          }
        } else {
          targetedBtn.style.display = 'none';
          burstBtn.style.display = 'none';
          reloadBtn.style.display = 'none';
          localStorage.removeItem('burstModeActive');
          useBtn.textContent = 'Use';
        }
        return;
      }
      
      // Both items available
      swapBtn.style.display = 'inline-block';
      const activeItem = items[activeItemIndex];
      console.log('[ACTIVE ITEM]', activeItem);
      nameElement.textContent = activeItem.name;
      displayItemDiceTable(activeItem.name);
      // Check if item has ammo and show reload button
      const itemStats = ITEM_STATS[activeItem.name];
      if (itemStats) {
        // Check for burst fire capability
        // Format can be: "S X / T Y / B Z" (full), "S X / T Y" (no burst), or "B Z" (burst-only)
        const apParts = itemStats.apCost ? itemStats.apCost.split('/').map(s => s.trim()) : [];
        console.log(`[BURST CHECK] ${activeItem.name} - apCost: "${itemStats.apCost}" - Parts:`, apParts, '- Length:', apParts.length);
        
        // Check if weapon has burst mode:
        // - Has 3 parts with valid burst value (S X / T Y / B Z)
        // - OR is burst-only (B X with no slashes)
        const hasBurst = (apParts.length === 3 && apParts[2] && apParts[2] !== '-') ||
                        (apParts.length === 1 && itemStats.apCost && itemStats.apCost.trim().startsWith('B '));
        const isBurstOnly = apParts.length === 1 && itemStats.apCost && itemStats.apCost.trim().startsWith('B ');
        
        console.log(`[BURST CHECK] ${activeItem.name} - hasBurst:`, hasBurst, '- isBurstOnly:', isBurstOnly);
        const isBurstMode = localStorage.getItem('burstModeActive') === 'true' && hasBurst;
        
        // For burst-only weapons, automatically enable burst mode
        if (isBurstOnly) {
          localStorage.setItem('burstModeActive', 'true');
        }
        
        // Hide targeted button when in burst mode
        targetedBtn.style.display = isBurstMode || isBurstOnly ? 'none' : 'inline-block';
        
        if (hasBurst) {
          // Only show toggle for weapons with multiple fire modes
          burstBtn.style.display = isBurstOnly ? 'none' : 'inline-block';
          if (!isBurstOnly) {
            updateBurstToggleButton();
          }
        } else {
          burstBtn.style.display = 'none';
          localStorage.removeItem('burstModeActive');
        }
        
        // Determine button text based on weapon type
        const isMeleeOrUnarmed = itemStats.skill === 'Unarmed' || itemStats.skill === 'Melee Weapons';
        
        if (itemStats.ammo && itemStats.ammo !== 'N/A') {
          reloadBtn.style.display = 'inline-block';
          if (isBurstOnly) {
            useBtn.textContent = 'Burst';
          } else {
            useBtn.textContent = isBurstMode ? 'Burst' : 'Fire';
          }
        } else {
          reloadBtn.style.display = 'none';
          useBtn.textContent = isMeleeOrUnarmed ? 'Swing' : 'Use';
        }
      } else {
        targetedBtn.style.display = 'none';
        burstBtn.style.display = 'none';
        reloadBtn.style.display = 'none';
        localStorage.removeItem('burstModeActive');
        useBtn.textContent = 'Use';
      }
    }

    function useActiveItem() {
      const items = getEquipmentItems();
      const currentIndex = parseInt(localStorage.getItem('activeItemIndex') || '0');
      const activeItem = items[currentIndex] || { name: currentIndex === 0 ? 'Punch' : 'Kick' };
      
      alert(`Using: ${activeItem.name}\n\nThis would trigger the item's use action. Implementation can include:\n- Consuming item (food, drugs, etc.)\n- Applying effects\n- Rolling dice for item action\n- Etc.`);
    }

    function targetedAttack() {
      const items = getEquipmentItems();
      const currentIndex = parseInt(localStorage.getItem('activeItemIndex') || '0');
      const activeItem = items[currentIndex];
      
      if (!activeItem) {
        alert('No weapon equipped for targeted attack.');
        return;
      }
      
      alert(`Performing targeted attack with ${activeItem.name}!\n\nThis allows you to aim for specific body parts for increased damage or special effects.`);
    }

    function toggleBurstMode() {
      const isBurstMode = localStorage.getItem('burstModeActive') === 'true';
      localStorage.setItem('burstModeActive', (!isBurstMode).toString());
      updateActiveItemDisplay();
    }

    function updateBurstToggleButton() {
      const burstBtn = qs('burst-mode-toggle-btn');
      const isBurstMode = localStorage.getItem('burstModeActive') === 'true';
      
      if (isBurstMode) {
        burstBtn.style.backgroundColor = '#f97316';
        burstBtn.style.borderColor = '#f97316';
      } else {
        burstBtn.style.backgroundColor = '#64748b';
        burstBtn.style.borderColor = '#64748b';
      }
    }

    function reloadActiveItem() {
      const items = getEquipmentItems();
      const currentIndex = parseInt(localStorage.getItem('activeItemIndex') || '0');
      const activeItem = items[currentIndex];
      
      if (!activeItem) {
        alert('No active weapon to reload.');
        return;
      }
      
      const itemStats = ITEM_STATS[activeItem.name];
      if (!itemStats || !itemStats.ammo || itemStats.ammo === 'N/A') {
        alert('This item cannot be reloaded.');
        return;
      }
      
      const reloadAP = itemStats.reloadap || '2';
      const ammoType = itemStats.ammotype || 'unknown';
      
      alert(`Reloading: ${activeItem.name}\n\nAmmo Type: ${ammoType}\nReload AP Cost: ${reloadAP}\n\nWeapon reloaded!`);
    }

    function swapActiveItem() {
      const items = getEquipmentItems();
      
      // If no items, swap between Punch (0) and Kick (1)
      if (items.length === 0) {
        const currentIndex = parseInt(localStorage.getItem('activeItemIndex') || '0');
        const newIndex = currentIndex === 0 ? 1 : 0;
        localStorage.setItem('activeItemIndex', newIndex);
        updateActiveItemDisplay();
        return;
      }
      
      if (items.length < 2) return;
      
      const currentIndex = parseInt(localStorage.getItem('activeItemIndex') || '0');
      const newIndex = currentIndex === 0 ? 1 : 0;
      
      localStorage.setItem('activeItemIndex', newIndex);
      updateActiveItemDisplay();
    }

    let tempSelectedItems = [null, null, null];
    let draggedItem = null;
    let allAvailableItems = [];

    // Item stats for dice table - maps item names to their stats
    // Database will be loaded dynamically
    let DATABASE = null;
    let ITEM_STATS = {
      'Punch': { flavor: 'Your fist. Always available, always ready.', dice: '1d3 + MD', weight: '‚Äî', armor: '‚Äî', skill: 'Unarmed', type: 'Unarmed' },
      'Kick': { flavor: 'A well-placed kick. More powerful than a punch.', dice: '1d4 + MD', weight: '‚Äî', armor: '‚Äî', skill: 'Unarmed', type: 'Unarmed' },
      'None': { flavor: 'No item selected.', dice: '‚Äî', weight: '‚Äî', armor: '‚Äî', skill: '‚Äî', type: '‚Äî' }
    };

    // Load database and build ITEM_STATS
    async function loadDatabase() {
      try {
        const response = await fetch('database.json');
        DATABASE = await response.json();
        console.log('[DATABASE] Loaded successfully');
        buildItemStats();
      } catch (error) {
        console.error('[DATABASE] Failed to load:', error);
      }
    }

    function buildItemStats() {
      if (!DATABASE) return;

      // Keep the hardcoded unarmed attacks and None
      const baseStats = { ...ITEM_STATS };
      ITEM_STATS = baseStats;

      // Process all categories
      const categories = ['weapons', 'armor', 'ammunition', 'equipment', 'chems'];
      
      categories.forEach(category => {
        if (DATABASE[category]) {
          console.log(`[BUILD STATS] Processing ${category}: ${DATABASE[category].length} items`);
          DATABASE[category].forEach(item => {
            const stats = {
              flavor: item.flavor || item.description || 'No description available.',
              dice: item.stats?.damage || '‚Äî',
              weight: item.weight ? `${item.weight} lbs` : '‚Äî',
              type: item.category || item.type || 'Unknown'
            };

            // Handle weapons
            if (category === 'weapons') {
              stats.apCost = item.stats?.ap || '‚Äî';
              stats.ammo = item.stats?.capacity || item.stats?.magazine || 'N/A';
              stats.ammotype = item.stats?.ammoType || 'N/A';
              stats.reloadap = item.stats?.reload || 'N/A';
              stats.range = item.stats?.range || 'N/A';
              stats.skill = item.stats?.skill || 'Guns';
              stats.armor = '‚Äî';
              
              // Debug logging for skill
              if (item.name) {
                console.log(`[ITEM BUILD] ${item.name} - Skill: ${stats.skill} (from item.stats.skill: ${item.stats?.skill})`);
              }
            }
            // Handle armor
            else if (category === 'armor') {
              stats.armor = item.stats?.ac ? `${item.stats.ac} AC` : '‚Äî';
              stats.dt_dr = item.stats?.dt_dr || {};
              stats.skill = '‚Äî';
              stats.dice = '‚Äî';
              stats.apCost = '‚Äî';
            }
            // Handle ammunition
            else if (category === 'ammunition') {
              // Auto-detect thrown items (grenades, etc.) and assign Throwing skill
              const isThrownItem = item.tags?.includes('thrown') || 
                                   item.tags?.includes('throwing') || 
                                   item.tags?.includes('grenade') ||
                                   item.type === 'explosive';
              
              stats.skill = item.stats?.skill || (isThrownItem ? 'Throwing' : '‚Äî');
              stats.armor = '‚Äî';
              stats.armorMod = item.stats?.armorMod || '‚Äî';
              stats.apCost = item.stats?.ap || '‚Äî';
              
              // Debug: Check if throwing items have skills
              if (isThrownItem) {
                console.log(`[ITEM BUILD AMMO/THROWN] ${item.name} - Skill: ${stats.skill} (from db: ${item.stats?.skill}, auto-detected: ${!item.stats?.skill})`);
              }
            }
            // Handle equipment and chems
            else {
              stats.skill = item.stats?.skill || '‚Äî';
              stats.armor = '‚Äî';
              stats.apCost = '‚Äî';
            }

            // Store by item name
            ITEM_STATS[item.name] = stats;
          });
        }
      });

      console.log('[ITEM_STATS] Built from database:', Object.keys(ITEM_STATS).length, 'items');
    }

    function displayItemDiceTable(itemName) {
      const tableBody = qs('dice-table-body');
      const flavorElement = qs('item-flavor-text');
      const stats = ITEM_STATS[itemName] || {
        flavor: 'No description available.',
        dice: '‚Äî',
        apCost: '‚Äî',
        weight: '‚Äî',
        armor: '‚Äî',
        skill: '‚Äî',
        type: 'Unknown'
      };
      
      console.log(`[DISPLAY ITEM] ${itemName} - Stats:`, stats);
      console.log(`[DISPLAY ITEM] Skill value:`, stats.skill);

      // Update flavor text
      flavorElement.textContent = stats.flavor || 'No description available.';

      const rows = [
        { label: 'Dice', value: stats.dice },
        { label: 'AP (S/T/B)', value: stats.apCost || '2/-/-'},
        { label: 'Ammo Type', value: stats.ammotype || 'N/A' },
        { label: 'Ammo', value: stats.ammo || 'N/A' },
        { label: 'Reload AP', value: stats.reloadap || 'N/A' },
        { label: 'Skill', value: stats.skill }
      ];

      tableBody.innerHTML = rows.map(row => `
        <tr style="border-bottom: 1px solid rgba(255, 255, 255, 0.05);">
          <td style="padding: 8px; color: #FFD700; font-weight: bold;">${row.label}</td>
          <td style="padding: 8px; color: ${row.value === '‚Äî' ? '#666' : '#4CAF50'}">${row.value}</td>
        </tr>
      `).join('');
    }

    function openEquipmentModal() {
      const stored = localStorage.getItem('characterData');
      if (!stored) {
        alert('No character data found.');
        return;
      }

      try {
        const characterData = JSON.parse(stored);
        const equipment = characterData.equipment || {};
        const allItems = equipment.items ? Object.values(equipment.items) : [];

        // Store all items for reference
        allAvailableItems = equipment.items ? Object.entries(equipment.items).map(([name, quantity], idx) => ({
          id: idx,
          name: name,
          quantity: quantity
        })) : [];

        // Load current selections
        const savedSelection = localStorage.getItem('equipmentItemSelection');
        if (savedSelection) {
          try {
            tempSelectedItems = JSON.parse(savedSelection);
          } catch (e) {
            tempSelectedItems = [null, null, null];
          }
        }

        console.log('[EQUIPMENT MODAL] Available items:', allAvailableItems);
        console.log('[EQUIPMENT MODAL] Current selection:', tempSelectedItems);

        // Populate available items list
        populateAvailableItems();

        // Update drop zone displays
        updateDropZoneDisplays();

        // Show modal
        qs('equipment-modal').style.display = 'flex';
      } catch (err) {
        console.error('[EQUIPMENT MODAL] Error:', err);
        alert('Error loading equipment data.');
      }
    }

    function populateAvailableItems() {
      const container = qs('available-items');
      
      // Filter out items that are already selected (if they have quantity 1)
      const availableForDisplay = allAvailableItems.filter(item => {
        const isSelected = tempSelectedItems.some(selected => selected && selected.id === item.id);
        return !isSelected;
      });

      if (!availableForDisplay || availableForDisplay.length === 0) {
        container.innerHTML = '<div style="color: #999; padding: 8px;">No equipment available</div>';
        return;
      }

      const html = availableForDisplay.map((item) => {
        const quantityDisplay = item.quantity > 1 ? ` <span style="color: #4CAF50;">(x${item.quantity})</span>` : '';
        return `
          <div 
            draggable="true" 
            ondragstart="handleDragStart(event, ${item.id})"
            ondragend="handleDragEnd(event)"
            ontouchstart="handleTouchStart(event, ${item.id})"
            ontouchend="handleTouchEnd(event)"
            ontouchmove="handleTouchMove(event)"
            style="padding: 12px; background-color: #333; color: #FFD700; border: 1px solid #666; border-radius: 4px; cursor: move; font-weight: bold; transition: all 0.2s ease; user-select: none; touch-action: none;"
            onmouseover="this.style.backgroundColor='#444'; this.style.borderColor='#FF9800';"
            onmouseout="this.style.backgroundColor='#333'; this.style.borderColor='#666';"
          >
            ${item.name}${quantityDisplay}
          </div>
        `;
      }).join('');

      container.innerHTML = html;
    }

    function removeEquipmentSlot(slotIndex) {
      console.log('[EQUIPMENT]', `Removing item from slot ${slotIndex}`);
      tempSelectedItems[slotIndex] = null;
      populateAvailableItems();
      updateDropZoneDisplays();
    }

    function updateDropZoneDisplays() {
      const item1Display = qs('item1-display');
      const item2Display = qs('item2-display');
      const armorDisplay = qs('armor-display');
      const item1Remove = qs('item1-remove');
      const item2Remove = qs('item2-remove');
      const armorRemove = qs('armor-remove');

      if (tempSelectedItems[0]) {
        item1Display.textContent = tempSelectedItems[0].name;
        item1Display.style.color = '#4CAF50';
        item1Remove.style.display = 'block';
      } else {
        item1Display.textContent = 'Drag item here';
        item1Display.style.color = '#999';
        item1Remove.style.display = 'none';
      }

      if (tempSelectedItems[1]) {
        item2Display.textContent = tempSelectedItems[1].name;
        item2Display.style.color = '#4CAF50';
        item2Remove.style.display = 'block';
      } else {
        item2Display.textContent = 'Drag item here';
        item2Display.style.color = '#999';
        item2Remove.style.display = 'none';
      }

      if (tempSelectedItems[2]) {
        armorDisplay.textContent = tempSelectedItems[2].name;
        armorDisplay.style.color = '#4CAF50';
        armorRemove.style.display = 'block';
      } else {
        armorDisplay.textContent = 'Drag armor here';
        armorDisplay.style.color = '#999';
        armorRemove.style.display = 'none';
      }
    }

    let touchItem = null;
    let touchStartElement = null;

    function handleTouchStart(event, itemIndex) {
      const item = allAvailableItems.find(i => i.id === itemIndex);
      if (item) {
        touchItem = item;
        touchStartElement = event.target;
        event.target.style.opacity = '0.5';
        event.target.style.backgroundColor = '#555';
      }
    }

    function handleTouchMove(event) {
      // Prevent default scrolling while dragging
      event.preventDefault();
    }

    function handleTouchEnd(event) {
      if (!touchItem || !touchStartElement) return;
      
      touchStartElement.style.opacity = '1';
      touchStartElement.style.backgroundColor = '#333';
      
      // Get the touch end position
      const touch = event.changedTouches[0];
      const elementBelow = document.elementFromPoint(touch.clientX, touch.clientY);
      const dropZone = elementBelow?.closest('[id^="drop-zone-"]');
      
      if (dropZone) {
        // Determine which slot this is
        const slotMap = {
          'drop-zone-1': 0,
          'drop-zone-2': 1,
          'drop-zone-armor': 2
        };
        const slotIndex = slotMap[dropZone.id];
        
        if (slotIndex !== undefined) {
          // Check armor slot restriction
          if (slotIndex === 2) {
            const itemStats = ITEM_STATS[touchItem.name];
            if (!itemStats || itemStats.type?.toLowerCase() !== 'armor') {
              alert('Only armor items can go in the armor slot.');
              touchItem = null;
              touchStartElement = null;
              return;
            }
          }
          
          // Check if item is already in another slot
          for (let i = 0; i < tempSelectedItems.length; i++) {
            if (i !== slotIndex && tempSelectedItems[i] && tempSelectedItems[i].id === touchItem.id) {
              touchItem = null;
              touchStartElement = null;
              return;
            }
          }
          
          // Assign item to slot
          tempSelectedItems[slotIndex] = touchItem;
          populateAvailableItems();
          updateDropZoneDisplays();
          
          // Reset drop zone styling
          dropZone.style.backgroundColor = '#2a2a2a';
          dropZone.style.borderColor = slotIndex === 2 ? '#9C27B0' : '#FF9800';
        }
      }
      
      touchItem = null;
      touchStartElement = null;
    }

    function handleDragStart(event, itemIndex) {
      const item = allAvailableItems.find(i => i.id === itemIndex);
      if (item) {
        draggedItem = item;
        event.dataTransfer.effectAllowed = 'copy';
        event.dataTransfer.setData('text/html', event.target.innerHTML);
        event.target.style.opacity = '0.5';
      }
    }

    function handleDragEnd(event) {
      event.target.style.opacity = '1';
      draggedItem = null;
    }

    function handleDragOver(event) {
      event.preventDefault();
      event.dataTransfer.dropEffect = 'copy';
      event.target.closest('[id^="drop-zone-"]').style.backgroundColor = '#FF9800';
      event.target.closest('[id^="drop-zone-"]').style.borderColor = '#FFD700';
    }

    function handleDragLeave(event) {
      const dropZone = event.target.closest('[id^="drop-zone-"]');
      dropZone.style.backgroundColor = '#2a2a2a';
      // Restore correct border color based on zone type
      const borderColor = dropZone.id === 'drop-zone-armor' ? '#9C27B0' : '#FF9800';
      dropZone.style.borderColor = borderColor;
    }

    function handleDrop(event, slotIndex) {
      event.preventDefault();
      
      const dropZone = event.target.closest('[id^="drop-zone-"]');
      dropZone.style.backgroundColor = '#2a2a2a';
      dropZone.style.borderColor = slotIndex === 2 ? '#9C27B0' : '#FF9800';

      if (draggedItem) {
        // Armor slot can only accept armor items
        if (slotIndex === 2) {
          const itemStats = ITEM_STATS[draggedItem.name];
          if (!itemStats || itemStats.type?.toLowerCase() !== 'armor') {
            console.log('[EQUIPMENT] Only armor items can go in the armor slot');
            alert('Only armor items can go in the armor slot.');
            return;
          }
        }

        // Check if item is already in any other slot
        for (let i = 0; i < tempSelectedItems.length; i++) {
          if (i !== slotIndex && tempSelectedItems[i] && tempSelectedItems[i].id === draggedItem.id) {
            console.log('[EQUIPMENT] Cannot assign same item to multiple slots');
            return;
          }
        }

        tempSelectedItems[slotIndex] = draggedItem;
        console.log('[EQUIPMENT SELECTION]', `Slot ${slotIndex}:`, tempSelectedItems[slotIndex]);
        
        // Refresh available items and displays
        populateAvailableItems();
        updateDropZoneDisplays();
      }
    }

    function populateItemList(listId, items, slotIndex) {
      const list = qs(listId);
      if (!items || items.length === 0) {
        list.innerHTML = '<div style="color: #999; padding: 8px;">No equipment available</div>';
        return;
      }

      const html = items.map((item, idx) => {
        const itemName = item.name || `Item ${idx}`;
        const itemId = item.id || idx;
        const isSelected = tempSelectedItems[slotIndex] !== null && 
                          (tempSelectedItems[slotIndex].id === itemId || tempSelectedItems[slotIndex].id === idx);
        
        const buttonStyle = isSelected
          ? 'background-color: #4CAF50; color: white; border: 2px solid #8BC34A;'
          : 'background-color: #333; color: #aaa; border: 2px solid #555;';

        return `
          <button 
            onclick="selectEquipmentItem(${slotIndex}, ${idx})"
            style="padding: 10px; ${buttonStyle} border-radius: 4px; cursor: pointer; text-align: left; font-weight: bold; transition: all 0.2s ease;"
            onmouseover="this.style.backgroundColor='#555'; this.style.borderColor='#777';"
            onmouseout="this.style.backgroundColor='${isSelected ? '#4CAF50' : '#333'}'; this.style.borderColor='${isSelected ? '#8BC34A' : '#555'}';"
          >
            ${isSelected ? '‚úì ' : ''}${itemName}
          </button>
        `;
      }).join('');

      list.innerHTML = html;
    }

    function selectEquipmentItem(slotIndex, itemIndex) {
      const stored = localStorage.getItem('characterData');
      if (!stored) return;

      try {
        const characterData = JSON.parse(stored);
        const allItems = characterData.equipment?.items ? Object.values(characterData.equipment.items) : [];
        
        if (itemIndex >= 0 && itemIndex < allItems.length) {
          tempSelectedItems[slotIndex] = {
            id: allItems[itemIndex].id || itemIndex,
            name: allItems[itemIndex].name || `Item ${itemIndex}`,
            index: itemIndex
          };

          console.log('[EQUIPMENT SELECTION]', `Slot ${slotIndex}:`, tempSelectedItems[slotIndex]);

          // Re-populate the list to show selection
          populateItemList(slotIndex === 0 ? 'item1-list' : 'item2-list', allItems, slotIndex);
        }
      } catch (err) {
        console.error('[EQUIPMENT SELECTION] Error:', err);
      }
    }

    function saveEquipmentConfiguration() {
      // Save to localStorage
      localStorage.setItem('equipmentItemSelection', JSON.stringify(tempSelectedItems));
      console.log('[EQUIPMENT SAVED]', tempSelectedItems);

      // Reset active item index to 0 since we're changing the items
      localStorage.setItem('activeItemIndex', '0');

      // Close modal and update display
      closeEquipmentModal();
      updateActiveItemDisplay();
      updateEquippedArmorDisplay();
    }

    function closeEquipmentModal() {
      qs('equipment-modal').style.display = 'none';
      tempSelectedItems = [null, null, null];
    }

    // Load character when page loads
    document.addEventListener('DOMContentLoaded', async function() {
      await loadDatabase();
      // Clear equipment selection on page load BEFORE loading character
      localStorage.removeItem('equipmentItemSelection');
      loadCharacter();
      updateActiveItemDisplay();
    });
  </script>
</body>
</html>
